{"mappings":"C,A,S,C,C,C,C,C,C,C,C,C,E,I,E,A,a,O,W,W,A,a,O,K,K,A,a,O,O,O,A,a,O,O,O,C,E,E,A,Y,O,C,C,E,E,C,C,E,C,E,E,K,E,C,E,E,A,a,O,Q,A,Y,O,O,O,E,O,O,C,I,C,Q,S,E,C,C,C,E,G,C,C,C,E,C,C,G,C,C,C,E,C,C,I,E,A,Y,O,C,C,E,E,C,C,E,C,G,C,G,E,O,E,E,C,G,G,E,O,E,E,C,G,G,G,A,U,O,E,O,E,G,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,O,C,S,C,E,I,E,C,C,E,C,E,C,E,C,O,A,M,E,E,C,E,E,K,C,C,E,I,E,C,C,E,C,I,E,M,C,G,C,C,E,C,E,C,I,C,E,O,C,E,E,E,O,C,I,C,C,O,C,C,E,C,O,C,S,E,C,E,I,E,E,O,C,G,M,A,C,I,E,C,E,E,E,C,C,E,e,C,C,E,E,M,C,S,C,E,I,C,E,C,E,I,C,M,C,E,I,C,O,C,C,C,E,E,O,C,E,E,K,C,E,E,M,C,E,E,Q,C,S,C,C,C,E,C,C,E,C,C,S,C,C,C,E,E,O,C,C,E,C,E,A,E,O,c,C,E,O,C,I,W,O,C,C,E,A,C,G,C,C,E,C,E,I,I,E,E,E,E,M,C,I,E,C,C,E,C,E,C,Q,C,S,C,C,C,C,C,E,I,E,E,kD,E,iB,C,GC+BA,EAAA,MAAA,CAAA,EAAA,OAAA,IAAS,EAAA,IAAI,EAqCb,EAAA,MAAA,CAAA,EAAA,WAAA,IAAa,GApEb,IAAA,EAAA,EAAA,mBACA,EAAA,EAAA,WACA,EAAA,EAAA,WACA,EAAA,EAAA,iBACA,EAAA,EAAA,oBAGA,IAAM,EAAU,AAAC,GAAkB,CAAA,WAAA,EAAc,EAAK,CAAE,CAClD,EAAW,sBAEX,EAAe,SACf,EAAe,SAEf,EAAoB,UAEpB,EAA0B,SAC1B,EAAkB,QAClB,EAAkB,QAClB,EAAkB,QAClB,EAAuB,aACvB,EAAiB,OAEjB,EAAqB,WAGrB,EAAqB,6CA8BvB,EAAkB,EAGhB,EAA0B,CAC/B,SAAU,EAAE,CACZ,WAAY,IAAM,CAAA,EAClB,SAAU,IAAM,KAAA,CAChB,CAMK,OAAO,EAOL,OAAO,oBAAP,CAMP,CAeA,YAAY,CAAW,CAAE,EAAmB,CAAA,CAAE,CAA9C,CACC,GATM,IAAA,CAAA,QAAQ,CAAmB,AAAA,EAAA,cAAA,CAAe,IAAI,CAShD,CAAC,GAAM,CAAE,CAAA,aAAc,OAAA,EAC1B,MAAM,AAAI,MAAM,CAAA,kCAAA,EAAsC,OAAO,EAAG,aAAA,CAAe,EAGhF,AAAA,CAAA,EAAA,EAAA,UAAA,AAAA,EAAW,IAAI,CAAE,EAAmB,GAIpC,IACA,EAAG,EAAE,CAAG,EAAG,EAAE,EAAI,EAAQ,GACzB,AAAA,CAAA,EAAA,EAAA,UAAA,AAAA,EAAW,IAAI,CA7FI,KA6FY,EAAG,EAAE,EAGpC,IAAM,EAAa,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,EAAQ,GAAa,GACxC,AAAA,CAAA,EAAA,EAAA,UAAA,AAAA,EAAW,IAAI,CAAE,EAAyB,GAK1C,IAAI,EAAwB,KACxB,EAAW,IAAI,EAAc,QAAQ,CAAC,CACpC,EAAQ,EAAc,QAAQ,CAAC,SAAS,CAAC,AAAC,GAAqB,aAAmB,EAAA,IAAI,EACxF,EAAQ,IAEX,CAAA,CAAC,EAAK,CAAG,EAAS,MAAM,CAAC,EAAO,EAAhC,EAED,MAAA,GAAA,CAAA,EAAS,IAAI,EAAA,IAAA,AAAb,EAEA,EAAW,CAAC,KADZ,EAAW,EAAS,MAAM,CAAC,AAAC,GAAqB,CAAE,CAAA,aAAmB,EAAA,IAAA,GACxC,CAC9B,AAAA,CAAA,EAAA,EAAA,UAAA,AAAA,EAAW,IAAI,CAAE,EAAgB,GAGjC,IAAM,EAAQ,IAAI,EAAA,KAAA,CAAM,IAAI,CAAE,GAM9B,OALA,AAAA,CAAA,EAAA,EAAA,UAAA,AAAA,EAAW,IAAI,CA7GO,QA6GY,GAClC,AAAA,CAAA,EAAA,EAAA,UAAA,AAAA,EAAW,IAAI,CAAE,EAAoB,GACrC,EAAS,OAAO,CAAC,AAAC,GAAY,EAAQ,IAAI,CAAC,IAGnC,CAAA,GAEP,KAAK,MAAM,OAAO,CAAC,EAAQ,KAAK,EAC/B,IAAI,CAAC,KAAK,CAAG,EAAQ,KAAc,CACnC,KAGD,KAAK,CAAC,MAAM,EAAQ,KAAe,EAClC,IAAI,CAAC,KAAK,CAAG,CAAC,EAAQ,KAAe,CAAC,AAEvC,CACD,IAAI,CAAC,QAAQ,CAAG,AAAA,EAAA,cAAA,CAAe,MAAM,CAerC,IAAI,CAAC,SAAS,CAAG,AAAA,CAAA,EAAA,EAAA,QAAA,AAAA,EAAS,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,EAAG,IACrD,IAAI,CAAC,SAAS,CAAG,AAAA,CAAA,EAAA,EAAA,QAAQ,AAAR,EAAS,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,EAAG,IACrD,EAAG,gBAAgB,CAAC,EAAc,IAAI,CAAC,SAAS,EAChD,OAAO,gBAAgB,CAAC,EAAc,IAAI,CAAC,SAAS,CAErD,CAQA,IAAW,IAAX,CACC,MAAO,AAAA,CAAA,EAAA,EAAA,SAAS,AAAT,EAAmB,IAAI,CAAE,EACjC,CAQA,IAAW,MAAX,C,I,EAEC,OAAO,AAAO,OAAP,CAAA,EAAA,AADM,AAAA,CAAA,EAAA,EAAA,SAAS,AAAT,EAAgB,IAAI,CAAE,GACvB,EAAA,AAAA,GAAE,AAAA,KAAA,IAAA,EAAA,EAAI,IACnB,CAOA,IAAW,IAAX,CACC,MAAO,AAAA,CAAA,EAAA,EAAA,SAAS,AAAT,EAAkB,IAAI,CArLV,KAsLpB,CAQA,IAAW,OAAX,CACC,MAAO,AAAA,CAAA,EAAA,EAAA,SAAA,AAAA,EAAU,IAAI,CAAE,EAAiB,KACvC,GAAM,CAAE,GAAA,CAAE,CAAE,MAAA,CAAK,CAAE,CAAG,IAAI,CACpB,CAAE,OAAA,CAAM,CAAE,CAAG,EACb,CAAE,YAAA,CAAW,CAAE,CAAG,EAClB,EAAY,EAAG,qBAAqB,GAAG,IAAI,CAE3C,EAAkB,EAAE,CACtB,EAAK,EAET,KAAM,EAAK,EAAQ,IAAM,CAExB,IAAM,EAAO,AADA,CAAK,CAAC,EAAG,CACJ,qBAAqB,GACjC,CAAE,MAAA,CAAK,CAAE,CAAG,EACd,CAAE,KAAA,CAAI,CAAE,CAAG,EACf,CAAA,GAAc,CAAd,EAEW,AArMW,IAqMX,GAA6B,GACvC,EAAO,AAAS,IAAT,GAAmC,GAC1C,EAAM,IAAI,CAAC,EAEZ,QAED,AAAI,AAAiB,IAAjB,EAAM,MAAM,CAGR,CAAC,EAAE,CAGJ,CACR,EACD,CASA,IAAW,MAAM,CAAa,CAA9B,CACC,GAAM,CAAE,SAAA,CAAQ,CAAE,GAAA,CAAE,CAAE,MAAA,CAAK,CAAE,CAAG,IAAI,CAC9B,CAAE,OAAA,CAAM,CAAE,CAAG,EAEnB,GAAI,CAAC,MAAM,OAAO,CAAC,IAAW,CAAC,EAAO,MAAM,CAC3C,OAGD,IAAI,EAAQ,CAAM,CAAC,EAAE,EAAI,EAGnB,CAAE,WAAA,CAAU,CAAE,CAAG,EAEjB,EAAK,CAAE,KAAM,CAAK,CAJxB,EAAQ,KAAK,GAAG,CAAC,KAAK,GAAG,CAAC,EAAO,EAAS,GAAI,GAIf,CAAC,UAAU,AAAA,EAItC,IAAU,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE,EAC7B,CAAA,EAAG,IAAI,CAAG,CAAA,EANU,IASH,EAAG,IAAI,GAIzB,AAAA,CAAA,EAAA,EAAA,UAAA,AAAA,EAAW,IAAI,CAAE,GAEjB,EAAG,QAAQ,CAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,EAAM,GAAE,CAAE,SAAA,CAAQ,IAC9B,CAOA,IAAW,OAAX,CACC,MAAO,AAAA,CAAA,EAAA,EAAA,SAAA,AAAA,EAAU,IAAI,CAAE,EAAiB,KACvC,GAAM,CAAE,WAAA,CAAU,CAAE,CAAG,AAAA,CAAA,EAAA,EAAA,SAAS,AAAT,EAAyB,IAAI,CAAE,GAChD,CAAE,GAAA,CAAE,CAAE,CAAG,IAAI,CAGnB,OAAO,AAFU,MAAM,IAAI,CAAC,EAAG,QAAQ,EAGrC,MAAM,CAAC,AAAC,GAAS,CAAC,EAAmB,IAAI,CAAC,EAAK,OAAO,GAAK,CAAC,EAAK,MAAM,EACvE,MAAM,CAAC,EACV,EACD,CAQA,IAAW,OAAX,CACC,MAAO,AAAA,CAAA,EAAA,EAAA,SAAA,AAAA,EAAU,IAAI,CAAE,EAAiB,KACvC,GAAM,CAAE,GAAA,CAAE,CAAE,MAAA,CAAK,CAAE,CAAG,IAAI,CACpB,CAAE,YAAa,CAAQ,CAAE,CAAG,EAElC,GAAI,AAAa,IAAb,EAKH,OAAO,EAAM,GAAG,CAAC,CAAC,EAAM,IAAU,CAAC,EAAe,EAUnD,IAAI,EAAqB,CAAC,EAAE,CAAC,CA4D7B,OA1DA,EACE,GAAG,CAAC,CAAC,EAAM,KAEX,GAAM,CAAE,WAAY,CAAI,CAAE,YAAa,CAAK,CAAE,CAAG,EACjD,MAAO,CAAE,KAAA,EAAM,MAAA,EAAO,KAAA,EAAM,MAAA,CAAK,CAClC,GACC,IAAI,CAAC,CAAC,EAAG,IAIF,EAAE,IAAI,CAAG,EAAE,IAAI,EAEtB,OAAO,CAAC,AAAC,IAaT,GAAM,CAAE,KAAA,CAAI,CAAE,MAAA,CAAK,CAAE,CAAG,EAElB,EAAW,CAAK,CAAC,EAAM,MAAM,CAAG,EAAE,CAClC,EAAY,CAAQ,CAAC,EAAE,CACzB,EAAQ,AAAA,CAAA,MAAA,EAAS,KAAA,EAAT,EAAW,IAAA,AAAA,GAAQ,EAM3B,IAAa,CAAK,CAAC,EAAE,EACxB,CAAA,EAAQ,CAAA,EAMT,IAAI,EAAM,KAAK,KAAK,CAAE,AAAC,CAAA,EAAO,EAAS,AAAS,IAAT,CAAa,EAAsB,GAE1E,KAAM,EAAM,GACX,EAAM,IAAI,CAAC,EAAE,EACb,IAID,AADa,CAAK,CAAC,EAAM,MAAM,CAAG,EAAE,CAC/B,IAAI,CAAC,EACX,GAOM,AAHP,CAAA,EAAQ,EAAM,MAAM,CAAC,AAAC,GAAS,AAAgB,IAAhB,EAAK,MAAM,CAA1C,EAGa,GAAG,CAAC,AAAC,GAAS,EAAK,GAAG,CAAC,CAAC,CAAE,MAAA,CAAK,CAAE,GAAK,GACpD,EACD,CAOA,IAAW,WAAX,CACC,MAAO,AAAA,CAAA,EAAA,EAAA,SAAA,AAAA,EAAU,IAAI,CAAE,EAAsB,KAC5C,GAAM,CAAE,GAAA,CAAE,CAAE,MAAA,CAAK,CAAE,MAAA,CAAK,CAAE,MAAA,CAAK,CAAE,CAAG,IAAI,CAClC,EAAY,EAAG,qBAAqB,GAAG,IAAI,CAC3C,CAAE,YAAA,CAAW,CAAE,CAAG,EAEpB,EAAqB,EAAM,MAAM,CAAY,CAAC,EAAK,KACtD,GAAI,CAAC,CAAK,CAAC,EAAG,CACb,OAAO,EAGR,GAAI,CAAE,KAAA,CAAI,CAAE,MAAA,CAAK,CAAE,CAAG,CAAK,CAAC,EAAG,CAAC,qBAAqB,SASrD,CAJA,EAAO,KAAK,KAAK,CAAC,EAAO,GACzB,EAAQ,KAAK,KAAK,CAAC,EAAQ,GAGvB,EAAO,GAAK,EAAc,GACtB,EAGD,EAAI,MAAM,CAAC,CAAC,EAAG,CACvB,EAAG,EAAE,CAKmB,CAAA,IAApB,EAAS,MAAM,EAClB,CAAA,EAAW,CAAC,CAAK,CAAC,EAAE,CAAC,AAAA,EAKtB,IAAM,EAAK,EAAS,IAAI,CAAC,CAAC,EAAG,KAC5B,IAAM,EAAS,CAAK,CAAC,EAAE,CAAC,qBAAqB,GAAG,KAAK,CAErD,OAAO,AADQ,CAAK,CAAC,EAAE,CAAC,qBAAqB,GAAG,KAAK,CACrC,CACjB,EAAE,CAAC,EAAE,CAGL,OAAO,EAAM,SAAS,CAAC,AAAC,GAAS,EAAK,QAAQ,CAAC,GAChD,EACD,CAOO,SAAA,CACN,GAAM,CAAE,GAAA,CAAE,CAAE,CAAG,IAAI,AAGnB,CAAA,EAAS,IAAI,CAAC,EAAG,EAAE,GAAK,EAAG,eAAe,CAAC,MAI3C,AADiB,AAAA,CAAA,EAAA,EAAA,SAAS,AAAT,EAAsB,IAAI,CAAE,GACpC,OAAO,CAAC,AAAC,GAAY,EAAQ,OAAO,IAS7C,EAAG,mBAAmB,CAAC,EAAc,IAAI,CAAC,SAAS,EACnD,OAAO,mBAAmB,CAAC,EAAc,IAAI,CAAC,SAAS,EAIvD,AAAA,CAAA,EAAA,EAAA,cAAc,AAAd,EAAe,IAAI,CACpB,CAQO,QAAA,CACN,AAAA,CAAA,EAAA,EAAA,UAAA,AAAA,EAAW,IAAI,CAAE,GACjB,AAAA,CAAA,EAAA,EAAA,UAAA,AAAA,EAAW,IAAI,CAAE,GACjB,AAAA,CAAA,EAAA,EAAA,UAAA,AAAA,EAAW,IAAI,CAAE,GACjB,AAAA,CAAA,EAAA,EAAA,UAAA,AAAA,EAAW,IAAI,CAAE,GAGjB,AADiB,AAAA,CAAA,EAAA,EAAA,SAAS,AAAT,EAAsB,IAAI,CAAE,GACpC,OAAO,CAAC,AAAC,GAAY,EAAQ,MAAM,CAAC,CAAE,KAAM,AAAA,EAAA,UAAU,CAAC,MAAM,AAAA,GACvE,CAEU,UAAU,CAAY,CAAtB,CACT,AAAA,CAAA,EAAA,EAAA,UAAA,AAAA,EAAW,IAAI,CAAE,GACjB,AAAA,CAAA,EAAA,EAAA,UAAA,AAAA,EAAW,IAAI,CAAE,GAGjB,AADiB,AAAA,CAAA,EAAA,EAAA,SAAS,AAAT,EAAsB,IAAI,CAAE,GACpC,OAAO,CAAC,AAAC,GAAY,EAAQ,MAAM,CAAC,CAAE,KAAM,AAAA,EAAA,UAAU,CAAC,MAAM,AAAA,IAEtE,GAAM,CAAE,MAAA,CAAK,CAAE,CAAG,IAAI,CAEtB,AADsB,AAAA,CAAA,EAAA,EAAA,SAAS,AAAT,EAAyB,IAAI,CAAE,GACvC,QAAQ,CAAW,CAAE,MAAA,EAAO,KAAM,EAAc,OAAQ,IAAI,CAAE,cAAe,CAAK,EACjG,CAEU,WAAA,CACT,AAAA,CAAA,EAAA,EAAA,UAAA,AAAA,EAAW,IAAI,CAAE,GACjB,AAAA,CAAA,EAAA,EAAA,UAAA,AAAA,EAAW,IAAI,CAAE,GACjB,AAAA,CAAA,EAAA,EAAA,UAAA,AAAA,EAAW,IAAI,CAAE,GAGjB,AADiB,AAAA,CAAA,EAAA,EAAA,SAAS,AAAT,EAAsB,IAAI,CAAE,GACpC,OAAO,CAAC,AAAC,GAAY,EAAQ,MAAM,CAAC,CAAE,KAAM,AAAA,EAAA,UAAU,CAAC,MAAM,AAAA,GACvE,CAEA,C,E,C,kB,Q,U,Q,U,Q,gB,Q,mB,Q,iD,O,E,C,M,C,S,C,C,C,C,C,MC/bG,E,I,E,E,kD,E,iB,C,GAeJ,EAAA,MAAA,CAAA,EAAA,OAAA,IAAa,GApEb,IAAA,EAAA,EAAA,eACA,EAAA,EAAA,qBAEA,EAAA,EAAA,eAKA,IAAM,EAAkB,OAClB,EAA0B,OAC1B,EAAiB,OACjB,EAAmB,OA6CnB,EAA0B,CAC/B,QAAS,CAAA,EACT,UAAW,kBACX,QAAS,KACT,CAQK,OAAO,EAMZ,YAAY,EAAmB,CAAA,CAAE,CAAjC,CACC,AAAA,CAAA,EAAA,EAAA,UAAA,AAAA,EAAW,IAAI,CAAE,EAAuB,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,EAAO,GAAa,GAC7D,CAKA,IAAW,MAAX,CACC,MA5EmB,cA6EpB,CAOA,IAAW,IAAX,C,I,EACC,OAAO,AAAwC,OAAxC,CAAA,EAAA,AAAA,CAAA,EAAA,EAAA,SAAS,AAAT,EAAmB,IAAI,CAAE,EAAA,GAAe,AAAA,KAAA,IAAA,EAAA,EAAI,IACpD,CAQO,KAAK,CAAa,CAAlB,CACN,AAAA,CAAA,EAAA,EAAA,UAAA,AAAA,EAAW,IAAI,CAAE,EAAiB,GAGlC,EAAc,MAAA,EAAA,EAAe,IAAI,EAAA,SAAA,CAEjC,IAAI,CAAC,OAAO,EACb,CAOO,SAAA,CACN,IAAI,CAAC,OAAO,GACZ,AAAA,CAAA,EAAA,EAAA,cAAc,AAAd,EAAe,IAAI,CACpB,CAWO,OAAO,CAAkB,CAAzB,CACN,OAAQ,EAAM,IAAI,EACjB,KAAK,AAAA,EAAA,UAAU,CAAC,MAAM,CACtB,KAAK,AAAA,EAAA,UAAU,CAAC,MAAM,CACrB,AAAA,CAAA,EAAA,EAAA,UAAA,AAAA,EAAW,IAAI,CAAE,GACjB,IAAI,CAAC,OAAO,GACZ,KACD,SACC,IAAI,CAAC,OAAO,EAEb,CACF,CAOQ,SAAA,CACP,GAAM,CAAE,QAAA,CAAO,CAAE,UAAA,CAAS,CAAE,QAAA,CAAO,CAAE,CAAG,AAAA,CAAA,EAAA,EAAA,SAAA,AAAA,EAAyB,IAAI,CAAE,GACvE,GAAI,CAAC,EACJ,OAID,IAAM,EAAU,AADF,AAAA,CAAA,EAAA,EAAA,SAAS,AAAT,EAAkB,IAAI,CAAE,GAChB,EAA8B,CAChD,CAAE,OAAA,CAAM,CAAE,CAAG,EAAY,UAAU,AAEnC,CAAA,EAAQ,WAAW,EAAI,EAAQ,WAAW,EAI7C,CAAA,EAAS,CAAA,EAIV,AAAA,CAAA,EAAA,EAAA,SAAA,AAAA,EAAmB,IAAI,CAAE,EAAgB,K,I,EACxC,IAAM,EAAO,SAAS,aAAa,CAAC,GAMpC,OALA,EAAK,SAAS,CAAG,EACjB,EAAK,KAAK,CAAC,QAAQ,CAAG,SACtB,EAAK,KAAK,CAAC,MAAM,CAAG,OACpB,AAAkB,OAAlB,CAAA,EAAA,EAAQ,UAAA,AAAA,GAAU,AAAA,KAAA,IAAA,GAAA,EAAE,YAAY,CAAC,EAAM,GACvC,EAAK,WAAW,CAAC,GACV,CACR,GAGI,IADiB,AAAA,CAAA,EAAA,EAAA,SAAS,AAAT,EAAkB,IAAI,CAAE,KAK7C,AAAA,CAAA,EAAA,EAAA,UAAA,AAAA,EAAW,IAAI,CAAE,EAAkB,GAEnC,EAAQ,KAAK,CAAC,MAAM,CAAG,CAAA,YAAA,EAAe,EAAM,GAAA,CAAK,CACjD,EAAQ,KAAK,CAAC,YAAY,CAAG,CAAA,EAAG,AAAS,GAAT,EAAW,EAAA,CAAI,CAChD,CAMQ,SAAA,C,I,E,EACP,GAAM,CAAE,GAAA,CAAE,CAAE,CAAG,AAAA,CAAA,EAAA,EAAA,SAAS,AAAT,EAAkB,IAAI,CAAE,GACjC,EAAO,AAAA,CAAA,EAAA,EAAA,SAAS,AAAT,EAA0B,IAAI,CAAE,EAE7C,AAAgB,QAAhB,CAAA,EAAA,MAAA,EAAI,KAAA,EAAJ,EAAM,UAAU,AAAV,GAAU,AAAA,KAAA,IAAA,GAAA,EAAE,YAAY,CAAC,EAAI,GACnC,AAAgB,OAAhB,CAAA,EAAA,MAAA,EAAI,KAAA,EAAJ,EAAM,UAAA,AAAA,GAAU,AAAA,KAAA,IAAA,GAAA,EAAE,WAAW,CAAC,GAC9B,EAAG,eAAe,CAAC,QACpB,CAEA,C,E,C,c,Q,oB,Q,c,Q,iD,O,E,C,Q,C,S,C,C,C,C,C,EChFE,IACS,EAYA,EAZA,EAYA,EAbT,EAAA,EAAA,kD,E,iB,C,GACS,EAAA,MAAA,CAAA,EAAA,aAAA,IAAA,GAYA,EAAA,MAAA,CAAA,EAAA,iBAAA,IAAA,GAXX,CADW,EAAA,GAAA,CAAA,EAAU,CAAA,CAAA,GACrB,MAAA,CAAA,SACA,EAAA,MAAA,CAAA,SACA,EAAA,MAAA,CAAA,SACA,EAAA,OAAA,CAAA,UASA,CADW,EAAA,GAAA,CAAA,EAAc,CAAA,CAAA,GACzB,IAAA,CAAA,OACA,EAAA,MAAA,CAAA,Q,E,C,iD,O,E,C,Q,C,S,C,C,C,C,C,ECrID,EAAQ,cAAc,CAAG,SAAU,CAAC,EAClC,OAAO,GAAK,EAAE,UAAU,CAAG,EAAI,CAAC,QAAS,CAAC,CAC5C,EAEA,EAAQ,iBAAiB,CAAG,SAAU,CAAC,EACrC,OAAO,cAAc,CAAC,EAAG,aAAc,CAAC,MAAO,CAAA,CAAI,EACrD,EAEA,EAAQ,SAAS,CAAG,SAAU,CAAM,CAAE,CAAI,EAkBxC,OAjBA,OAAO,IAAI,CAAC,GAAQ,OAAO,CAAC,SAAU,CAAG,EAE7B,YAAR,GACA,AAAQ,eAAR,GACA,OAAO,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,EAAM,IAK7C,OAAO,cAAc,CAAC,EAAM,EAAK,CAC/B,WAAY,CAAA,EACZ,IAAK,WACH,OAAO,CAAM,CAAC,EAAI,AACpB,CACF,EACF,GAEO,CACT,EAEA,EAAQ,MAAM,CAAG,SAAU,CAAI,CAAE,CAAQ,CAAE,CAAG,EAC5C,OAAO,cAAc,CAAC,EAAM,EAAU,CACpC,WAAY,CAAA,EACZ,IAAK,CACP,EACF,C,E,C,E,C,Q,C,S,C,C,C,C,C,E,I,E,E,kD,E,iB,C,GCHA,EAAA,MAAA,CAAA,EAAA,YAAA,IAAgB,GAuBhB,EAAA,MAAA,CAAA,EAAA,aAAA,IAAgB,GAWhB,EAAA,MAAA,CAAA,EAAA,aAAA,IAAgB,GAahB,EAAA,MAAA,CAAA,EAAA,iBAAA,IAAgB,GAUH,EAAA,MAAA,CAAA,EAAA,gBAAA,IAAA,GAjFb,IAAM,EAAU,IAAI,QAwBd,SAAU,EAAuB,CAAc,CAAE,CAAW,CAAE,CAAiB,EACpF,IAAM,EAAU,EAAQ,GAAG,CAAC,IAAQ,IAAI,IACxC,GAAI,EAAQ,GAAG,CAAC,GACf,OAAO,EAAQ,GAAG,CAAC,GAGpB,GAAI,CAAC,EACJ,OAGD,IAAM,EAAQ,IAGd,OAFA,EAAQ,GAAG,CAAC,EAAK,GACjB,EAAQ,GAAG,CAAC,EAAK,GACV,CACR,CASM,SAAU,EAAwB,CAAc,CAAE,CAAW,CAAE,CAAQ,EAC5E,IAAM,EAAU,EAAQ,GAAG,CAAC,IAAQ,IAAI,IACxC,EAAQ,GAAG,CAAC,EAAK,GACjB,EAAQ,GAAG,CAAC,EAAK,EAClB,CAOM,SAAU,EAAW,CAAc,CAAE,CAAW,EACrD,IAAM,EAAU,EAAQ,GAAG,CAAC,GACvB,GAAY,EAAQ,GAAG,CAAC,IAI7B,EAAQ,MAAM,CAAC,EAChB,CAMM,SAAU,EAAe,CAAc,EAC5C,EAAQ,MAAM,CAAC,EAChB,CAQO,IAAM,EAA8D,I,E,C,iD,O,E,C,M,C,S,C,C,C,C,C,E,I,E,E,kD,E,iB,C,GClE3E,EAAA,MAAA,CAAA,EAAA,YAAA,IAAa,GAtBb,IAAA,EAAA,EAAA,qBAeA,IAAM,EAAuB,MAOvB,OAAO,EAMZ,aAAA,CACC,OAAO,gBAAgB,CAAC,SAAU,KACjC,AAAA,CAAA,EAAA,EAAA,UAAA,AAAA,EAAW,IAAI,CAAE,EAClB,EACD,CAUA,IAAI,YAAJ,CACC,MAAO,AAAA,CAAA,EAAA,EAAA,SAAA,AAAA,EAA+B,IAAI,CAAE,EAAsB,KACjE,IAAM,EAAQ,SAAS,aAAa,CAAC,OAC/B,EAAQ,SAAS,aAAa,CAAC,OAErC,SAAS,IAAI,CAAC,WAAW,CAAC,GAC1B,EAAM,KAAK,CAAC,QAAQ,CAAG,WACvB,EAAM,KAAK,CAAC,GAAG,CAAG,MAClB,EAAM,KAAK,CAAC,IAAI,CAAG,MACnB,EAAM,KAAK,CAAC,UAAU,CAAG,SACzB,EAAM,WAAW,CAAC,GAiBlB,EAAM,KAAK,CAAC,KAAK,CAAG,QACpB,EAAM,KAAK,CAAC,MAAM,CAAG,OACrB,EAAM,KAAK,CAAC,KAAK,CAAG,QACpB,EAAM,KAAK,CAAC,MAAM,CAAG,QACrB,EAAM,KAAK,CAAC,QAAQ,CAAG,SAEvB,IAAM,EAAK,EAAM,YAAY,AAC7B,CAAA,EAAM,KAAK,CAAC,QAAQ,CAAG,SACvB,IAAI,EAAK,EAAM,YAAY,CAC3B,EAAM,IAAO,EAAM,EAAM,YAAY,CAAG,EACxC,IAAM,EAAS,EAAK,EAIpB,OAFA,SAAS,IAAI,CAAC,WAAW,CAAC,GAEnB,CAEN,OAAA,CACA,CACF,EACD,CAEA,C,E,C,oB,Q,iD,O,E,C,M,C,S,C,C,C,C,C,E,I,E,E,kD,E,iB,C,GC7DD,EAAA,MAAA,CAAA,EAAA,QAAA,IAAa,GA7Bb,IAAA,EAAA,EAAA,WACA,EAAA,EAAA,iBAGA,IAAM,EAAqB,OACrB,EAAqB,OAO3B,SAAS,EAAc,CAAU,EAChC,MAAO,AAAA,CAAA,EAAA,EAAA,SAAS,AAAT,EAAqB,EAAK,EAClC,CAeM,MAAO,EAOZ,YAAY,CAAmB,CAAE,CAAoB,CAArD,CACC,AAAA,CAAA,EAAA,EAAA,UAAA,AAAA,EAAW,IAAI,CAAE,EAAoB,GACrC,AAAA,CAAA,EAAA,EAAA,UAAA,AAAA,EAAW,IAAI,CAAE,EAAoB,EACtC,CAKA,IAAW,IAAX,CACC,OAAO,EAAc,IAAI,EAAE,EAAE,AAC9B,CAKA,IAAW,IAAX,CACC,OAAO,EAAc,IAAI,EAAE,EAAE,AAC9B,CAKA,IAAW,MAAX,CACC,OAAO,EAAc,IAAI,EAAE,IAAI,AAChC,CAKA,IAAW,OAAX,CACC,OAAO,EAAc,IAAI,EAAE,KAAK,AACjC,CAKA,IAAW,MAAM,CAAY,CAA7B,CACC,EAAc,IAAI,EAAE,KAAK,CAAG,CAC7B,CAKA,IAAW,OAAX,CACC,OAAO,EAAc,IAAI,EAAE,KAAK,AACjC,CAKA,IAAW,OAAX,CACC,OAAO,EAAc,IAAI,EAAE,KAAK,AACjC,CAKA,IAAW,WAAX,CACC,OAAO,EAAc,IAAI,EAAE,SAAS,AACrC,CAOO,OAAO,CAAgB,CAAvB,CACN,EAAc,IAAI,EAAE,MAAM,GAI1B,AArFM,AAAA,CAAA,EAAA,EAAA,SAAS,AAAT,EAqFQ,IAAI,CArFe,GAqFb,OAAO,CAAC,AAAC,IACxB,IAAY,GAIhB,EAAQ,MAAM,CAAC,CAAE,KAAM,AAAA,EAAA,UAAU,CAAC,OAAO,AAAA,EAC1C,EACD,CAEA,C,E,C,U,Q,gB,Q,iD,O,E,C,Q,C,S,C,C,C,C,C,EC9FE,IAAA,EAAA,EAAA,kDACG,SAAU,EAA2B,CAAO,CAAE,CAAa,EAChE,IAAI,EAAgD,KASpD,MARkB,CAAC,GAAG,KACL,OAAZ,GACH,aAAa,GAGd,EAAU,WAAW,IAAM,KAAQ,GAAO,EAC3C,CAGD,C,E,iB,C,GAXA,EAAA,MAAA,CAAA,EAAA,WAAA,IAAgB,E,E,C,iD,O,E,C,M,C,S,C,C,C,C,C,E,I,E,E,kD,E,iB,C,GCmGhB,EAAA,MAAA,CAAA,EAAA,UAAA,IAAa,GAzHb,IAAA,EAAA,EAAA,qBACA,EAAA,EAAA,sB,E,S,C,C,C,E,I,E,C,E,I,I,K,E,O,S,C,c,C,I,C,E,I,A,E,E,O,C,I,C,C,C,E,C,C,C,E,A,E,G,A,M,G,A,Y,O,O,qB,C,I,I,E,E,E,O,qB,C,G,E,E,M,C,I,E,E,O,C,C,C,E,G,O,S,C,oB,C,I,C,E,C,C,E,G,C,C,C,C,C,E,C,C,C,C,C,C,E,C,A,E,O,C,EAKA,IAAM,EAAkB,OAClB,EAA0B,OAC1B,EAAoB,OAEpB,EAAc,QA0Fd,EAA0B,CAC/B,SAAU,CAAC,CAAE,UAAA,CAAS,CAAE,SAAA,CAAQ,CAAE,MAAA,CAAK,CAAE,MAAA,CAAK,CAAW,GAAK,CAA9D;+BACgC,EAAA,EAAS,cAAA,EAAiB,EAAK,SAAA,EAAY,EAAK,iBAAA,EAAoB,EAApE;SACtB,EAAA,EAAA;;CAET,CAAA,CACD,UAAW,SAEX,cAAe,UACf,UAAW,OACX,UAAW,aAEX,kBAAmB,cACnB,cAAe,WACf,cAAe,gBACf,CAMK,OAAO,EAMZ,YAAY,EAAmB,CAAA,CAAE,CAAjC,CACC,AAAA,CAAA,EAAA,EAAA,UAAA,AAAA,EAAW,IAAI,CAAE,EAAuB,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,EAAO,GAAa,IAC5D,IAAI,CAAC,OAAO,CAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,EACrC,IAAI,CAAC,OAAO,CAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CACtC,CAKA,IAAW,MAAX,CACC,MArImB,iBAsIpB,CAQO,KAAK,CAAa,CAAlB,CACN,AAAA,CAAA,EAAA,EAAA,UAAA,AAAA,EAAW,IAAI,CAAE,EAAiB,GAClC,IAAI,CAAC,OAAO,EACb,CAOO,SAAA,CACN,IAAI,CAAC,OAAO,GACZ,AAAA,CAAA,EAAA,EAAA,cAAc,AAAd,EAAe,IAAI,CACpB,CASO,QAAA,CACN,IAAI,CAAC,OAAO,EACb,CAQQ,SAAA,CACP,IAAM,EAAQ,AAAA,CAAA,EAAA,EAAA,SAAS,AAAT,EAAkB,IAAI,CAAE,GAChC,EAAS,AAAA,CAAA,EAAA,EAAA,SAAS,AAAT,EAAyB,IAAI,CAAE,GAExC,CAAE,GAAA,CAAE,CAAE,KAAA,CAAI,CAAE,MAAA,CAAK,CAAE,UAAA,CAAS,CAAE,CAAG,EAIjC,CAAC,EAAM,EAAS,CAAG,AAAA,CAAA,EAAA,EAAA,SAAA,AAAA,EACxB,IAAI,CAAE,EAAmB,KACxB,IAAM,EAAS,MAAA,EAAA,EAAQ,EACjB,CACL,SAAA,CAAQ,CAAE,UAAA,CAAS,CACnB,kBAAA,CAAiB,CAAE,cAAA,CAAa,CAAE,cAAA,CAAa,CAC/C,cAAA,CAAa,CAAE,UAAA,CAAS,CAAE,UAAA,CAAS,CACnC,CAAG,EA0BJ,MAAO,AAvBU,CAChB,CACC,SAAU,EAAG,EAAE,CACf,MAAO,EACP,MAAO,EACP,UAAW,CAAC,EAAW,EAAc,CAAC,IAAI,CAAC,KAI3C,QAAS,IAAI,CAAC,OAAO,AACrB,EACD,CACC,SAAU,EAAG,EAAE,CACf,MAAO,EACP,MAAO,EACP,UAAW,CAAC,EAAW,EAAkB,CAAC,IAAI,CAAC,KAI/C,QAAS,IAAI,CAAC,OAAO,AACrB,EACD,CAEe,GAAG,CAAC,AAAC,IAAA,I,EAAA,CAAE,QAAA,CAAO,CAAA,CAAA,EAAK,EAAM,EAAA,EAApB,CAAA,UAAsB,EAC1C,IAAM,EAAS,AAAA,CAAA,EAAA,EAAA,MAAA,AAAA,EAAmC,EAAU,UAC5D,AAAK,GAIL,EAAO,gBAAgB,CAAC,EAAa,GACrC,AAAiB,OAAjB,CAAA,EAAA,EAAO,UAAU,AAAV,GAAU,AAAA,KAAA,IAAA,GAAA,EAAE,YAAY,CAAC,EAAQ,EAAO,WAAW,EACnD,GALC,IAMT,EACD,GAGD,GAAI,EAAM,CACT,IAAM,EAAW,CAAK,CAAC,EAAY,EAAE,AAErC,CAAA,EAAK,QAAQ,CADM,AAAa,KAAA,IAAb,CAEnB,CAED,GAAI,EAAU,CACb,IAAM,EAAY,CAAK,CAAC,EAAY,EAAE,AAEtC,CAAA,EAAS,QAAQ,CADG,AAAc,KAAA,IAAd,CAEpB,CACF,CAMQ,SAAA,CACP,IAAM,EAAU,AAAA,CAAA,EAAA,EAAA,SAAS,AAAT,EAAoB,IAAI,CAAE,EAE1C,OAAA,GAAA,EAAS,OAAO,CAAC,AAAC,I,I,CAIjB,OAAA,GAAA,EAAQ,mBAAmB,CAAC,EAAa,IAAI,CAAC,OAAO,EAIrD,MAAA,GAAA,EAAQ,mBAAmB,CAAC,EAAa,IAAI,CAAC,OAAO,EACrD,AAAkB,OAAlB,CAAA,EAAA,MAAA,EAAM,KAAA,EAAN,EAAQ,UAAA,AAAA,GAAU,AAAA,KAAA,IAAA,GAAA,EAAE,WAAW,CAAC,EACjC,EACD,CAMQ,SAAA,CACP,IAAM,EAAQ,AAAA,CAAA,EAAA,EAAA,SAAS,AAAT,EAAkB,IAAI,CAAE,GAChC,CAAE,MAAA,CAAK,CAAE,UAAA,CAAS,CAAE,CAAG,EACvB,EAAQ,CAAK,CAAC,EAAY,EAAE,EAAI,CAAK,CAAC,EAAE,AAC9C,CAAA,EAAM,KAAK,CAAG,CACf,CAMQ,SAAA,CACP,IAAM,EAAQ,AAAA,CAAA,EAAA,EAAA,SAAS,AAAT,EAAkB,IAAI,CAAE,GAChC,CAAE,MAAA,CAAK,CAAE,UAAA,CAAS,CAAE,CAAG,EACvB,EAAQ,CAAK,CAAC,EAAY,EAAE,EAAI,CAAK,CAAC,EAAM,MAAM,CAAG,EAAE,AAC7D,CAAA,EAAM,KAAK,CAAG,CACf,CAEA,C,E,C,oB,Q,qB,Q,iD,O,E,C,M,C,S,C,C,C,C,C,ECvRE,IAAA,EAAA,EAAA,kDACG,SAAU,EACf,CAAsC,CACtC,CAAgB,EAEhB,IAAM,EAAK,SAAS,aAAa,CAAC,cAClC,EAAG,SAAS,CAAG,EAAS,GAGxB,AADY,EAAG,iBAAiB,EAExB,IAIT,C,E,iB,C,GAbA,EAAA,MAAA,CAAA,EAAA,SAAA,IAAgB,E,E,C,iD,O,E,C,M,C,S,C,C,C,C,C,E,I,E,E,kD,E,iB,C,GC0FhB,EAAA,MAAA,CAAA,EAAA,QAAA,IAAa,GAnGb,IAAA,EAAA,EAAA,qBAKA,IAAM,EAAkB,OAClB,EAA0B,OAC1B,EAAuB,QACvB,EAAuB,OACvB,EAAwB,OACxB,EAAoB,OAEpB,EAAc,OAId,EAAa,YACb,EAAY,UAelB,SAAS,EAAe,CAAY,SACnC,AAAI,aAAiB,WACb,EAAM,OAAO,CAGd,CACR,CAqDA,IAAM,EAA0B,CAC/B,UAAW,CAAA,CACX,CAMK,OAAO,EAMZ,YAAY,EAAmB,CAAA,CAAE,CAAjC,CACC,AAAA,CAAA,EAAA,EAAA,UAAA,AAAA,EAAW,IAAI,CAAE,EAAuB,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,EAAO,GAAa,IAC5D,IAAI,CAAC,QAAQ,CAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,EACvC,IAAI,CAAC,OAAO,CAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,EACrC,IAAI,CAAC,MAAM,CAAG,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CACpC,CAKA,IAAI,MAAJ,CACC,MAjHmB,eAkHpB,CAQO,KAAK,CAAa,CAAlB,CACN,AAAA,CAAA,EAAA,EAAA,UAAA,AAAA,EAAW,IAAI,CAAE,EAAiB,GAElC,IAAM,EAAS,AAAA,CAAA,EAAA,EAAA,SAAS,AAAT,EAAyB,IAAI,CAAE,GACxC,CAAE,GAAA,CAAE,CAAE,CAAG,CAEf,CADgB,EACR,KAAK,CAAC,MAAM,CAAG,EAAO,SAAS,CAAG,EAAc,GAKxD,EAAG,gBAAgB,CAzHD,YAyHe,IAAI,CAAC,QAAQ,CAAE,CAAE,QAAS,CAAA,CAAI,EAChE,CAOO,SAAA,CACN,AAAA,CAAA,EAAA,EAAA,cAAc,AAAd,EAAe,IAAI,CACpB,CASO,QAAA,CAEP,CAOQ,SAAS,CAAY,CAArB,C,I,EAEP,aADgB,AAAA,CAAA,EAAA,EAAA,SAAS,AAAT,EAAkB,IAAI,CAAE,IAGxC,IAAM,EAAS,AAAA,CAAA,EAAA,EAAA,SAAS,AAAT,EAAyB,IAAI,CAAE,GACxC,EAAQ,AAAA,CAAA,EAAA,EAAA,SAAS,AAAT,EAAkB,IAAI,CAAE,GAChC,EAAU,EAAM,EAAiB,CACvC,AAAA,CAAA,EAAA,EAAA,SAAS,AAAT,EAAU,IAAI,CAAE,EAAuB,IAAc,EAAQ,UAAU,EACvE,AAAA,CAAA,EAAA,EAAA,SAAA,AAAA,EAAU,IAAI,CAAE,EAAsB,IAAc,EAAe,IACnE,AAAA,CAAA,EAAA,EAAA,SAAS,AAAT,EAAU,IAAI,CAAE,EAAsB,IAAc,EAAM,SAAS,EAInE,EAAQ,KAAK,CAAC,UAAU,CAAG,OAC3B,EAAQ,KAAK,CAAC,cAAc,CAAG,OAC/B,EAAQ,KAAK,CAAC,cAAc,CAAG,OAC/B,EAAQ,KAAK,CAAC,MAAM,CAAG,EAAO,SAAS,CAvKjB,WAuKsC,GAK5D,OAAO,gBAAgB,CAAC,EAAY,IAAI,CAAC,OAAO,CAAE,CAAE,QAAS,CAAA,CAAI,GACjE,OAAO,gBAAgB,CAAC,EAAW,IAAI,CAAC,MAAM,CAAE,CAAE,QAAS,CAAA,CAAI,GAI/D,AAAc,OAAd,CAAA,EAAA,EAAO,OAAA,AAAA,GAAO,AAAA,KAAA,IAAA,GAAA,EAAA,IAAA,CAAA,EAAG,CAAE,cAAe,CAAK,EACxC,CAOQ,QAAQ,CAAY,CAApB,C,I,E,E,EACP,IAAM,EAAS,AAAA,CAAA,EAAA,EAAA,SAAS,AAAT,EAAyB,IAAI,CAAE,GACxC,CAAE,GAAA,CAAE,CAAE,CAAG,AAAA,CAAA,EAAA,EAAA,SAAS,AAAT,EAAkB,IAAI,CAAE,GACjC,EAAO,AAA8C,OAA9C,CAAA,EAAA,AAAA,CAAA,EAAA,EAAA,SAAS,AAAT,EAAkB,IAAI,CAAE,EAAA,GAAsB,AAAA,KAAA,IAAA,EAAA,EAAI,EACzD,EAAI,AAA6C,OAA7C,CAAA,EAAA,AAAA,CAAA,EAAA,EAAA,SAAS,AAAT,EAAkB,IAAI,CAAE,EAAA,GAAqB,AAAA,KAAA,IAAA,EAAA,EAAI,EACrD,EAAW,EAAe,EAGhC,CAAA,EAAG,UAAU,CAAG,EAFD,CAAA,EAAI,CAAnB,EAKA,AAAa,OAAb,CAAA,EAAA,EAAO,MAAA,AAAA,GAAM,AAAA,KAAA,IAAA,GAAA,EAAA,IAAA,CAAA,EAAG,CAAE,cAAe,CAAK,EACvC,CAOQ,OAAO,CAAY,CAAnB,C,I,E,E,E,EACP,IAAM,EAAQ,AAAA,CAAA,EAAA,EAAA,SAAS,AAAT,EAAkB,IAAI,CAAE,GAChC,EAAS,AAAA,CAAA,EAAA,EAAA,SAAS,AAAT,EAAyB,IAAI,CAAE,GACxC,EAAO,AAA8C,OAA9C,CAAA,EAAA,AAAA,CAAA,EAAA,EAAA,SAAS,AAAT,EAAkB,IAAI,CAAE,EAAA,GAAsB,AAAA,KAAA,IAAA,EAAA,EAAI,EACzD,EAAY,AAA6C,OAA7C,CAAA,EAAA,AAAA,CAAA,EAAA,EAAA,SAAS,AAAT,EAAkB,IAAI,CAAE,EAAA,GAAqB,AAAA,KAAA,IAAA,EAAA,EAAI,EACnE,AAAA,CAAA,EAAA,EAAA,UAAA,AAAA,EAAW,IAAI,CAAE,GACjB,AAAA,CAAA,EAAA,EAAA,UAAA,AAAA,EAAW,IAAI,CAAE,GACjB,AAAA,CAAA,EAAA,EAAA,UAAA,AAAA,EAAW,IAAI,CAAE,GAEjB,IAAM,EAAU,EAAM,EAAiB,CACjC,EAAY,KAAK,GAAG,CAAC,KAAK,GAAG,CAhNf,IAgN+B,AA9M5B,IA8M4B,EAAQ,WAAW,EA/MlD,KAiNd,EAAW,AADG,EAAQ,UAAU,CACP,EACzB,EAAS,KAAK,GAAG,CAAC,GAExB,EAAQ,KAAK,CAAC,cAAc,CAAC,eAC7B,EAAQ,KAAK,CAAC,cAAc,CAAC,mBAC7B,EAAQ,KAAK,CAAC,MAAM,CAAG,EAAO,SAAS,CAAG,EAAc,GAIxD,IAAI,EAAQ,EAAM,KAAK,CACnB,EAAS,GAGZ,CAAA,EAAQ,AAAe,OAAf,CAAA,EAAA,EAAM,KAAK,CADR,KAAK,GAAG,CAAC,EADF,EAAW,EACc,GACpB,AAAH,GAAG,AAAA,KAAA,IAAA,EAAA,EAAI,CAA3B,EAMD,OAAO,qBAAqB,CAAC,KAC5B,EAAM,KAAK,CAAG,CACf,GAKA,IAAM,EAAU,OAAO,UAAU,CAAC,KACjC,EAAQ,KAAK,CAAC,cAAc,CAAC,mBAC9B,EAAG,KAEH,AAAA,CAAA,EAAA,EAAA,UAAA,AAAA,EAAW,IAAI,CAAE,EAAmB,GAKpC,OAAO,mBAAmB,CAAC,EAAY,IAAI,CAAC,OAAO,EACnD,OAAO,mBAAmB,CAAC,EAAW,IAAI,CAAC,MAAM,EAIjD,AAAY,OAAZ,CAAA,EAAA,EAAO,KAAA,AAAA,GAAK,AAAA,KAAA,IAAA,GAAA,EAAA,IAAA,CAAA,EAAG,CAAE,cAAe,CAAK,EACtC,CAEA,C,E,C,oB,Q,iD,O,E,C,M,C,S,C,C,C,C,C,E,I,E,E,kD,E,iB,C,GChKD,EAAA,MAAA,CAAA,EAAA,aAAA,IAAa,GAjHb,IAAA,EAAA,EAAA,eACA,EAAA,EAAA,qBACA,EAAA,EAAA,sBAKA,IAAM,EAAkB,OAClB,EAA0B,OAC1B,EAAuB,OACvB,EAAoB,OA2EpB,EAA0B,CAG/B,SAAU,CAAC,CAAE,UAAA,CAAS,CAAE,SAAA,CAAQ,CAAE,MAAA,CAAK,CAAE,MAAA,CAAK,CAAE,MAAA,CAAK,CAAW,GAAK,CAArE;aACc,EAAA,EAAA;GACV,EAAA,EAAM,GAAG,CAAC,CAAC,EAAM,KAClB,IAAM,EAAO,CAAE,MAAA,EAAO,KAAA,EAAM,MAAA,CAAK,EAC3B,EAAW,EAAM,GACjB,EAAW,EAAM,GACvB,MAAO,CAAP;0CACwC,EAAA,EAAQ,cAAA,EAAiB,EAAQ,SAAA,EAAY,EAA7C;YAC9B,EAAA,EAAA;;SAEJ,CAAA,AACP,GAAG,IAAI,CAAC,IAAR;;CAED,CAAA,CAGD,UAAW,aACX,MAAO,CAAC,CAAE,MAAA,CAAK,CAAE,GAAK,CAAA,EAAG,EAAQ,EAAC,CAAE,CACpC,MAAO,CAAC,CAAE,MAAA,CAAK,CAAE,GAAK,CAAA,MAAA,EAAS,EAAQ,EAAC,MAAA,CAAQ,AAChD,CAMK,OAAO,EAMZ,YAAY,EAAmB,CAAA,CAAE,CAAjC,CACC,AAAA,CAAA,EAAA,EAAA,UAAA,AAAA,EAAW,IAAI,CAAE,EAAuB,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,EAAO,GAAa,IAC5D,IAAI,CAAC,QAAQ,CAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CACxC,CAKA,IAAW,MAAX,CACC,MA3HmB,oBA4HpB,CAQO,KAAK,CAAa,CAAlB,CACN,AAAA,CAAA,EAAA,EAAA,UAAA,AAAA,EAAW,IAAI,CAAE,EAAiB,GAClC,IAAI,CAAC,IAAI,EACV,CAOO,SAAA,CACN,IAAI,CAAC,OAAO,GACZ,AAAA,CAAA,EAAA,EAAA,cAAc,AAAd,EAAe,IAAI,CACpB,CAWO,OAAO,CAAkB,CAAzB,CACE,EAAM,IAAI,GACZ,AAAA,EAAA,UAAU,CAAC,MAAM,CACrB,IAAI,CAAC,OAAO,IAGZ,IAAI,CAAC,OAAO,GACZ,IAAI,CAAC,IAAI,GAGZ,CAOQ,MAAA,C,I,EACP,IAAM,EAAQ,AAAA,CAAA,EAAA,EAAA,SAAS,AAAT,EAAkB,IAAI,CAAE,GAChC,EAAS,AAAA,CAAA,EAAA,EAAA,SAAS,AAAT,EAAyB,IAAI,CAAE,GACxC,CAAE,GAAA,CAAE,CAAE,KAAA,CAAI,CAAE,MAAA,CAAK,CAAE,CAAG,EAG5B,GAAI,EAAM,MAAM,CAAG,EAClB,OAGD,GAAM,CAAE,SAAA,CAAQ,CAAE,UAAA,CAAS,CAAE,MAAA,CAAK,CAAE,MAAA,CAAK,CAAE,CAAG,EACxC,EAAa,AAAA,CAAA,EAAA,EAAA,MAAA,AAAA,EAAO,EAAU,CAAE,MAAA,EAAO,MAAA,EAAO,MAAA,EAAO,UAAA,EAAW,SAAU,EAAG,EAAE,AAAA,GAErF,GAAI,CAAC,EACJ,OAID,IAAM,EAAU,MAAM,IAAI,CAAC,EAAW,gBAAgB,CAAoB,WACxE,GAAG,CAAC,AAAC,IAIL,EAAO,gBAAgB,CAAC,QAAS,IAAI,CAAC,QAAQ,CAAE,CAAA,GACzC,GAGT,AAAiB,QAAjB,CAAA,EAAA,AAvBe,CAAA,MAAA,EAAA,EAAQ,CAAvB,EAuBO,UAAA,AAAA,GAAU,AAAA,KAAA,IAAA,GAAA,EAAE,WAAW,CAAC,GAC/B,AAAA,CAAA,EAAA,EAAA,UAAA,AAAA,EAAW,IAAI,CAAE,EAAsB,GACvC,AAAA,CAAA,EAAA,EAAA,UAAA,AAAA,EAAW,IAAI,CAAE,EAAmB,GAEpC,IAAI,CAAC,OAAO,EACb,CAMQ,SAAA,CACP,IAAM,EAAQ,AAAA,CAAA,EAAA,EAAA,SAAS,AAAT,EAAkB,IAAI,CAAE,GAChC,EAAU,AAAA,CAAA,EAAA,EAAA,SAAS,AAAT,EAA+B,IAAI,CAAE,GAE/C,CAAE,UAAA,CAAS,CAAE,CAAG,CACtB,OAAA,GAAA,EAAS,OAAO,CAAC,CAAC,EAAQ,IAAO,EAAO,QAAQ,CAAI,IAAO,EAC5D,CAMQ,SAAA,C,I,EACP,IAAM,EAAa,AAAA,CAAA,EAAA,EAAA,SAAS,AAAT,EAAuB,IAAI,CAAE,GAC1C,EAAU,AAAA,CAAA,EAAA,EAAA,SAAS,AAAT,EAA+B,IAAI,CAAE,EAErD,OAAA,GAAA,EAAS,OAAO,CAAC,AAAC,I,I,EAIjB,EAAO,mBAAmB,CAAC,QAAS,IAAI,CAAC,QAAQ,EACjD,AAAiB,OAAjB,CAAA,EAAA,EAAO,UAAA,AAAA,GAAU,AAAA,KAAA,IAAA,GAAA,EAAE,WAAW,CAAC,EAChC,GACA,AAAsB,OAAtB,CAAA,EAAA,MAAA,EAAU,KAAA,EAAV,EAAY,UAAA,AAAA,GAAU,AAAA,KAAA,IAAA,GAAA,EAAE,WAAW,CAAC,GAEpC,AAAA,CAAA,EAAA,EAAA,UAAA,AAAA,EAAW,IAAI,CAAE,GACjB,AAAA,CAAA,EAAA,EAAA,UAAA,AAAA,EAAW,IAAI,CAAE,EAClB,CASQ,SAAS,CAAiB,CAA1B,CACP,IAAM,EAAQ,AAAA,CAAA,EAAA,EAAA,SAAS,AAAT,EAAkB,IAAI,CAAE,GAChC,EAAU,AAAA,CAAA,EAAA,EAAA,SAAS,AAAT,EAA+B,IAAI,CAAE,GACrD,GAAI,CAAC,EACJ,OAGD,IAAM,EAAS,EAAM,aAAkC,CACjD,EAAQ,EAAQ,OAAO,CAAC,EAC9B,CAAA,EAAM,KAAK,CAAG,EAAM,KAAK,CAAC,EAAM,AACjC,CAEA,C,E,C,c,Q,oB,Q,qB,Q,iD,O,E,E,E,C,E","sources":["<anon>","src/carousel.ts","src/features/mask/index.ts","src/types.ts","node_modules/@parcel/transformer-js/src/esmodule-helpers.js","src/utils/cache.ts","src/features/mask/scrollbar.ts","src/proxy.ts","src/utils/debounce.ts","src/features/buttons/index.ts","src/utils/render.ts","src/features/mouse/index.ts","src/features/pagination/index.ts"],"sourcesContent":["// modules are defined as an array\n// [ module function, map of requires ]\n//\n// map of requires is short require name -> numeric require\n//\n// anything defined in a previous bundle is accessed via the\n// orig method which is the require for previous bundles\n\n(function (modules, entry, mainEntry, parcelRequireName, globalName) {\n  /* eslint-disable no-undef */\n  var globalObject =\n    typeof globalThis !== 'undefined'\n      ? globalThis\n      : typeof self !== 'undefined'\n      ? self\n      : typeof window !== 'undefined'\n      ? window\n      : typeof global !== 'undefined'\n      ? global\n      : {};\n  /* eslint-enable no-undef */\n\n  // Save the require from previous bundle to this closure if any\n  var previousRequire =\n    typeof globalObject[parcelRequireName] === 'function' &&\n    globalObject[parcelRequireName];\n\n  var cache = previousRequire.cache || {};\n  // Do not use `require` to prevent Webpack from trying to bundle this call\n  var nodeRequire =\n    typeof module !== 'undefined' &&\n    typeof module.require === 'function' &&\n    module.require.bind(module);\n\n  function newRequire(name, jumped) {\n    if (!cache[name]) {\n      if (!modules[name]) {\n        // if we cannot find the module within our internal map or\n        // cache jump to the current global require ie. the last bundle\n        // that was added to the page.\n        var currentRequire =\n          typeof globalObject[parcelRequireName] === 'function' &&\n          globalObject[parcelRequireName];\n        if (!jumped && currentRequire) {\n          return currentRequire(name, true);\n        }\n\n        // If there are other bundles on this page the require from the\n        // previous one is saved to 'previousRequire'. Repeat this as\n        // many times as there are bundles until the module is found or\n        // we exhaust the require chain.\n        if (previousRequire) {\n          return previousRequire(name, true);\n        }\n\n        // Try the node require function if it exists.\n        if (nodeRequire && typeof name === 'string') {\n          return nodeRequire(name);\n        }\n\n        var err = new Error(\"Cannot find module '\" + name + \"'\");\n        err.code = 'MODULE_NOT_FOUND';\n        throw err;\n      }\n\n      localRequire.resolve = resolve;\n      localRequire.cache = {};\n\n      var module = (cache[name] = new newRequire.Module(name));\n\n      modules[name][0].call(\n        module.exports,\n        localRequire,\n        module,\n        module.exports,\n        this\n      );\n    }\n\n    return cache[name].exports;\n\n    function localRequire(x) {\n      var res = localRequire.resolve(x);\n      return res === false ? {} : newRequire(res);\n    }\n\n    function resolve(x) {\n      var id = modules[name][1][x];\n      return id != null ? id : x;\n    }\n  }\n\n  function Module(moduleName) {\n    this.id = moduleName;\n    this.bundle = newRequire;\n    this.exports = {};\n  }\n\n  newRequire.isParcelRequire = true;\n  newRequire.Module = Module;\n  newRequire.modules = modules;\n  newRequire.cache = cache;\n  newRequire.parent = previousRequire;\n  newRequire.register = function (id, exports) {\n    modules[id] = [\n      function (require, module) {\n        module.exports = exports;\n      },\n      {},\n    ];\n  };\n\n  Object.defineProperty(newRequire, 'root', {\n    get: function () {\n      return globalObject[parcelRequireName];\n    },\n  });\n\n  globalObject[parcelRequireName] = newRequire;\n\n  for (var i = 0; i < entry.length; i++) {\n    newRequire(entry[i]);\n  }\n\n  if (mainEntry) {\n    // Expose entry point to Node, AMD or browser globals\n    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js\n    var mainExports = newRequire(mainEntry);\n\n    // CommonJS\n    if (typeof exports === 'object' && typeof module !== 'undefined') {\n      module.exports = mainExports;\n\n      // RequireJS\n    } else if (typeof define === 'function' && define.amd) {\n      define(function () {\n        return mainExports;\n      });\n\n      // <script>\n    } else if (globalName) {\n      this[globalName] = mainExports;\n    }\n  }\n})({\"2E9Dl\":[function(require,module,exports) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\n/**\n * Export the mask because it's used by default inside the carousel.\n */ parcelHelpers.export(exports, \"Mask\", ()=>(0, _mask.Mask));\n/**\n * The carousel instance.\n */ parcelHelpers.export(exports, \"Carousel\", ()=>Carousel);\nvar _mask = require(\"./features/mask\");\nvar _proxy = require(\"./proxy\");\nvar _types = require(\"./types\");\nvar _cache = require(\"./utils/cache\");\nvar _debounce = require(\"./utils/debounce\");\nconst ID_NAME = (count)=>`caroucssel-${count}`;\nconst ID_MATCH = /^caroucssel-[0-9]*$/;\nconst EVENT_SCROLL = \"scroll\";\nconst EVENT_RESIZE = \"resize\";\nconst CACHE_KEY_ELEMENT = \"element\";\nconst CACHE_KEY_ID = \"id\";\nconst CACHE_KEY_CONFIGURATION = \"config\";\nconst CACHE_KEY_INDEX = \"index\";\nconst CACHE_KEY_ITEMS = \"items\";\nconst CACHE_KEY_PAGES = \"pages\";\nconst CACHE_KEY_PAGE_INDEX = \"page-index\";\nconst CACHE_KEY_MASK = \"mask\";\nconst CACHE_KEY_PROXY = \"proxy\";\nconst CACHE_KEY_FEATURES = \"feautres\";\nconst VISIBILITY_OFFSET = 0.25;\nconst INVISIBLE_ELEMENTS = /^(link|meta|noscript|script|style|title)$/i;\n/*\n * Internal counter for created instances. Will be used to create unique IDs.\n */ let __instanceCount = 0;\nconst DEFAULTS = {\n    features: [],\n    filterItem: ()=>true,\n    onScroll: ()=>undefined\n};\nclass Carousel {\n    /**\n     * This will be used for testing purposes to reset the instance count which is\n     * used to create unique id's.\n     * @internal\n     */ static resetInstanceCount() {}\n    /**\n     * Creates an instance.\n     * @param el is the dom element to control. This should be a container element\n     * \tthat holds child elements that will scroll horizontally.\n     * @param options are the options to configure this instance.\n     */ constructor(el, options = {}){\n        /**\n         * Current scroll behavior. Possible values are:\n         * * `'auto'`\n         * * `'smooth'`\n         */ this.behavior = (0, _types.ScrollBehavior).AUTO;\n        if (!el || !(el instanceof Element)) throw new Error(`Carousel needs a dom element but \"${typeof el}\" was passed.`);\n        (0, _cache.writeCache)(this, CACHE_KEY_ELEMENT, el);\n        // Count all created instances to create unique id, if given dom element\n        // has no id-attribute:\n        __instanceCount++;\n        el.id = el.id || ID_NAME(__instanceCount);\n        (0, _cache.writeCache)(this, CACHE_KEY_ID, el.id);\n        // Extend options and defaults into configuration:\n        const configuration = Object.assign(Object.assign({}, DEFAULTS), options);\n        (0, _cache.writeCache)(this, CACHE_KEY_CONFIGURATION, configuration);\n        // Detect if there is a \"Mask\" feature passed as option. Then use this one,\n        // otherwise add a mandatory instance by default. Also ensure that only one\n        // feature of type \"Mask\" is in the features list.\n        let mask = null;\n        let features = [\n            ...configuration.features\n        ];\n        const index = configuration.features.findIndex((feature)=>feature instanceof (0, _mask.Mask));\n        if (index > -1) // Extract first found instance of \"Mask\":\n        [mask] = features.splice(index, 1);\n        mask !== null && mask !== void 0 ? mask : mask = new (0, _mask.Mask)();\n        features = features.filter((feature)=>!(feature instanceof (0, _mask.Mask)));\n        features = [\n            mask,\n            ...features\n        ];\n        (0, _cache.writeCache)(this, CACHE_KEY_MASK, mask);\n        // Features: Initialize all features with a single proxy instance inbetween.\n        const proxy = new (0, _proxy.Proxy)(this, features);\n        (0, _cache.writeCache)(this, CACHE_KEY_PROXY, proxy);\n        (0, _cache.writeCache)(this, CACHE_KEY_FEATURES, features);\n        features.forEach((feature)=>feature.init(proxy));\n        // Set initial index and finally set smooth scrolling to enabled:\n        switch(true){\n            // When index is a list:\n            case Array.isArray(options.index):\n                this.index = options.index;\n                break;\n            // When index is a number, transfrom to list:\n            case !isNaN(options.index):\n                this.index = [\n                    options.index\n                ];\n                break;\n        }\n        this.behavior = (0, _types.ScrollBehavior).SMOOTH;\n        // Debounced events:\n        //\n        // Where do these magic numbers come from? The numbers are the results of\n        // testing the behavior in several browsers and are considered at \"best fit\"\n        // without visible side effects to the UI. The value for the \"scroll\" event\n        // correlates with the timing of scroll-behaviour: smooth.\n        //\n        // We disable @typescript-eslint/unbound-method here because we already bound\n        // the functions while creating a debounced version. This would also cause\n        // reference errors when tying to access these function references when used\n        // with removeEventListeners() (see: destroy())\n        //\n        /* eslint-disable @typescript-eslint/unbound-method */ this._onScroll = (0, _debounce.debounce)(this._onScroll.bind(this), 45);\n        this._onResize = (0, _debounce.debounce)(this._onResize.bind(this), 25);\n        el.addEventListener(EVENT_SCROLL, this._onScroll);\n        window.addEventListener(EVENT_RESIZE, this._onResize);\n    /* eslint-enable @typescript-eslint/unbound-method */ }\n    /**\n     * Returns the dom element reference of the carousel which was passed into the\n     * constructor.\n     * @public\n     * @return the controlled dom element\n     */ get el() {\n        return (0, _cache.fromCache)(this, CACHE_KEY_ELEMENT);\n    }\n    /**\n     * Returns the dom element reference of the mask element that wraps the\n     * carousel element.\n     * @public\n     * @return the mask dom element\n     */ get mask() {\n        var _a;\n        const mask = (0, _cache.fromCache)(this, CACHE_KEY_MASK);\n        return (_a = mask.el) !== null && _a !== void 0 ? _a : null;\n    }\n    /**\n     * Returns the id-attribute value of the carousel.\n     * @public\n     * @return the id of the controlled dom element\n     */ get id() {\n        return (0, _cache.fromCache)(this, CACHE_KEY_ID);\n    }\n    /**\n     * Returns the current index of the carousel. The returned index is a list (array)\n     * of indexes that are currently visible (depending on each item width).\n     * @public\n     * @return a list of visible indexes\n     */ get index() {\n        return (0, _cache.fromCache)(this, CACHE_KEY_INDEX, ()=>{\n            const { el, items } = this;\n            const { length } = items;\n            const { clientWidth } = el;\n            const outerLeft = el.getBoundingClientRect().left;\n            const index = [];\n            let at = 0;\n            for(; at < length; at++){\n                const item = items[at];\n                const rect = item.getBoundingClientRect();\n                const { width } = rect;\n                let { left } = rect;\n                left = left - outerLeft;\n                if (left + width * VISIBILITY_OFFSET >= 0 && left + width * (1 - VISIBILITY_OFFSET) <= clientWidth) index.push(at);\n            }\n            if (index.length === 0) // If no index found, we return a [0] as default. This possibly happens\n            // when the carousel is not attached to the DOM or is visually hidden (display: none).\n            return [\n                0\n            ];\n            return index;\n        });\n    }\n    /**\n     * Sets the current index of the carousel. To set an index you need to pass an\n     * array with at least one element. When passing more than one, the rest will\n     * be ignored.\n     * @public\n     * @param values are the upcoming indexes\n     */ set index(values) {\n        const { behavior, el, items } = this;\n        const { length } = items;\n        if (!Array.isArray(values) || !values.length) return;\n        let value = values[0] || 0;\n        value = Math.max(Math.min(value, length - 1), 0);\n        const { scrollLeft } = el;\n        const from = {\n            left: scrollLeft\n        };\n        const to = {\n            left: items[value].offsetLeft\n        };\n        // If the target item is the first visible element in the list, ignore\n        // the possible offset to the left and scroll to the beginning of the list:\n        if (value === this.pages[0][0]) to.left = 0;\n        if (from.left === to.left) return;\n        (0, _cache.clearCache)(this, CACHE_KEY_INDEX);\n        el.scrollTo(Object.assign(Object.assign({}, to), {\n            behavior\n        }));\n    }\n    /**\n     * Returns an array of all child dom elements of the carousel.\n     * @public\n     * @return a list of elements (child elements of the root element)\n     */ get items() {\n        return (0, _cache.fromCache)(this, CACHE_KEY_ITEMS, ()=>{\n            const { filterItem } = (0, _cache.fromCache)(this, CACHE_KEY_CONFIGURATION);\n            const { el } = this;\n            const children = Array.from(el.children);\n            return children.filter((item)=>!INVISIBLE_ELEMENTS.test(item.tagName) && !item.hidden).filter(filterItem);\n        });\n    }\n    /**\n     * Returns an array of all pages. Each page is a group of indexes that matches\n     * a page.\n     * @public\n     * @return the list of pages and indexes inside each page\n     */ get pages() {\n        return (0, _cache.fromCache)(this, CACHE_KEY_PAGES, ()=>{\n            const { el, items } = this;\n            const { clientWidth: viewport } = el;\n            if (viewport === 0) // if the width of the carousel element is zero, we can not calculate\n            // the pages properly and the carousel seems to be not visible. If\n            // this is the case, we assume that each item is placed on a\n            // separate page.\n            return items.map((item, index)=>[\n                    index\n                ]);\n            let pages = [\n                []\n            ];\n            items.map((item, index)=>{\n                // Create a re-usable dataset for each item:\n                const { offsetLeft: left, clientWidth: width } = item;\n                return {\n                    left,\n                    width,\n                    item,\n                    index\n                };\n            }).sort((a, b)=>{\n                // Create ordered list of items based on their visual ordering.\n                // This may differ from the DOM ordering unsing css properties\n                // like `order` in  flexbox or grid:\n                return a.left - b.left;\n            }).forEach((item)=>{\n                // Calculate pages / page indexes for each item:\n                //\n                // The idea behind the calculation of the pages is to separate\n                // the items by fitting them into the viewport of the carousel.\n                // To behave correctly, we cannot divide the total length of the\n                // carousel by the viewport to get the page indexes (naive approach).\n                // However, since there may be items that are partially visible\n                // on a page, but mathematically create a new page. The calculation\n                // must start from this item again. This means that always the\n                // first item on a page sets the basis for the calculation of\n                // the following item and its belonging to the current or next\n                // page:\n                const { left, width } = item;\n                const prevPage = pages[pages.length - 1];\n                const firstItem = prevPage[0];\n                let start = (firstItem === null || firstItem === void 0 ? void 0 : firstItem.left) || 0;\n                // This is required for the first page. The first page always\n                // needs to start from the left=0. Any offset from the\n                // left of the first visual item needs to be ignored, otherwise\n                // the calculation of visual pages is incorrect:\n                if (prevPage === pages[0]) start = 0;\n                // At least 75% of the items needs to be in the page. Calculate\n                // the amount of new pages to add. If value is 0, the current\n                // item fits into the previous page:\n                let add = Math.floor((left - start + width * (1 - VISIBILITY_OFFSET)) / viewport);\n                while(add > 0){\n                    pages.push([]);\n                    add--;\n                }\n                const page = pages[pages.length - 1];\n                page.push(item);\n            });\n            // Remove empty pages: this might happen if items are wider than the\n            // carousel viewport:\n            pages = pages.filter((page)=>page.length !== 0);\n            // Restructure pages to only contain the index of each item:\n            return pages.map((page)=>page.map(({ index })=>index));\n        });\n    }\n    /**\n     * Returns the index of the current page.\n     * @public\n     * @return the index of the current page\n     */ get pageIndex() {\n        return (0, _cache.fromCache)(this, CACHE_KEY_PAGE_INDEX, ()=>{\n            const { el, items, index, pages } = this;\n            const outerLeft = el.getBoundingClientRect().left;\n            const { clientWidth } = el;\n            let visibles = index.reduce((acc, at)=>{\n                if (!items[at]) return acc;\n                let { left, right } = items[at].getBoundingClientRect();\n                // \"getBoundingClientRect()\" can return float numbers which\n                // lead to an unwanted behavior when in the calculation with\n                // \"clientWidth\" (not using floats). We use round here to\n                // normalize those values...\n                left = Math.round(left - outerLeft);\n                right = Math.round(right - outerLeft);\n                // Remove items that partially hidden to the left or right:\n                if (left < 0 || clientWidth < right) return acc;\n                return acc.concat([\n                    at\n                ]);\n            }, []);\n            // There might be no possible candidates. This is the case when items\n            // are wider than the element viewport. In this case we take the first\n            // item which is currently visible in general (might be the only one):\n            if (visibles.length === 0) visibles = [\n                index[0]\n            ];\n            // Search for the visible item that is most aligned to the right. The\n            // found item marks the current page...\n            const at = visibles.sort((a, b)=>{\n                const rightA = items[a].getBoundingClientRect().right;\n                const rightB = items[b].getBoundingClientRect().right;\n                return rightB - rightA;\n            })[0];\n            // Find the page index where the current item index is located...\n            return pages.findIndex((page)=>page.includes(at));\n        });\n    }\n    /**\n     * This completely deconstructs the carousel and returns the dom to its\n     * initial state.\n     * @public\n     */ destroy() {\n        const { el } = this;\n        // Remove created id if it was created by carousel:\n        ID_MATCH.test(el.id) && el.removeAttribute(\"id\");\n        // Destroy attached features:\n        const features = (0, _cache.fromCache)(this, CACHE_KEY_FEATURES);\n        features.forEach((feature)=>feature.destroy());\n        // Remove events:\n        //\n        // We need to work the the function reference. Using .bind() would create a\n        // new referenced instance of the callback function. We already created a\n        // bound version of these function within the constructor.\n        //\n        /* eslint-disable @typescript-eslint/unbound-method */ el.removeEventListener(EVENT_SCROLL, this._onScroll);\n        window.removeEventListener(EVENT_RESIZE, this._onResize);\n        /* eslint-enable @typescript-eslint/unbound-method */ // Clear cache:\n        (0, _cache.clearFullCache)(this);\n    }\n    /**\n     * Enforces an update of all enabled components of the carousel. This is, for\n     * example, useful when changing the number of items inside the carousel. This\n     * also forwards an update call to all attached features.\n     * @public\n     */ update() {\n        (0, _cache.clearCache)(this, CACHE_KEY_INDEX);\n        (0, _cache.clearCache)(this, CACHE_KEY_ITEMS);\n        (0, _cache.clearCache)(this, CACHE_KEY_PAGES);\n        (0, _cache.clearCache)(this, CACHE_KEY_PAGE_INDEX);\n        const features = (0, _cache.fromCache)(this, CACHE_KEY_FEATURES);\n        features.forEach((feature)=>feature.update({\n                type: (0, _types.UpdateType).FORCED\n            }));\n    }\n    _onScroll(event) {\n        (0, _cache.clearCache)(this, CACHE_KEY_INDEX);\n        (0, _cache.clearCache)(this, CACHE_KEY_PAGE_INDEX);\n        const features = (0, _cache.fromCache)(this, CACHE_KEY_FEATURES);\n        features.forEach((feature)=>feature.update({\n                type: (0, _types.UpdateType).SCROLL\n            }));\n        const { index } = this;\n        const configuration = (0, _cache.fromCache)(this, CACHE_KEY_CONFIGURATION);\n        configuration.onScroll({\n            index,\n            type: EVENT_SCROLL,\n            target: this,\n            originalEvent: event\n        });\n    }\n    _onResize() {\n        (0, _cache.clearCache)(this, CACHE_KEY_PAGES);\n        (0, _cache.clearCache)(this, CACHE_KEY_INDEX);\n        (0, _cache.clearCache)(this, CACHE_KEY_PAGE_INDEX);\n        const features = (0, _cache.fromCache)(this, CACHE_KEY_FEATURES);\n        features.forEach((feature)=>feature.update({\n                type: (0, _types.UpdateType).RESIZE\n            }));\n    }\n}\n\n},{\"./features/mask\":\"lTT8l\",\"./proxy\":\"d3Dm4\",\"./types\":\"9eV98\",\"./utils/cache\":\"032tB\",\"./utils/debounce\":\"5IcXl\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"78Tkd\"}],\"lTT8l\":[function(require,module,exports) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\n/**\n * The feature to enable/disabled mask and scrollbar support. This feature will\n * be added by default to each carousel. Use this feature to customize the\n * default behaviour.\n */ parcelHelpers.export(exports, \"Mask\", ()=>Mask);\nvar _types = require(\"../../types\");\nvar _cache = require(\"../../utils/cache\");\nvar _scrollbar = require(\"./scrollbar\");\nconst FEATURE_NAME = \"buildin:mask\";\nconst CACHE_KEY_PROXY = \"prxy\";\nconst CACHE_KEY_CONFIGURATION = \"conf\";\nconst CACHE_KEY_MASK = \"mask\";\nconst CACHE_KEY_HEIGHT = \"hght\";\n/**\n * Singleton of scrollbar util. Is shared across all instances of carousel to\n * reduce redundant calculations.\n * @internal\n */ let __scrollbar;\nconst DEFAULTS = {\n    enabled: true,\n    className: \"caroucssel-mask\",\n    tagName: \"div\"\n};\nclass Mask {\n    /**\n     * Creates an instance of this feature.\n     * @param options are the options to configure this instance\n     */ constructor(options = {}){\n        (0, _cache.writeCache)(this, CACHE_KEY_CONFIGURATION, Object.assign(Object.assign({}, DEFAULTS), options));\n    }\n    /**\n     * Returns the name of this feature.\n     */ get name() {\n        return FEATURE_NAME;\n    }\n    /**\n     * Returns the rendered element that wraps the carousel. If not enabled, this\n     * returns `null`.\n     * @return the mask element, otherwise `null` if disabled.\n     */ get el() {\n        var _a;\n        return (_a = (0, _cache.fromCache)(this, CACHE_KEY_MASK)) !== null && _a !== void 0 ? _a : null;\n    }\n    /**\n     * Initializes this feature. This function will be called by the carousel\n     * instance and should not be called manually.\n     * @internal\n     * @param proxy the proxy instance between carousel and feature\n     */ init(proxy) {\n        (0, _cache.writeCache)(this, CACHE_KEY_PROXY, proxy);\n        // Create a singleton instance of scrollbar for all carousel instances:\n        __scrollbar = __scrollbar !== null && __scrollbar !== void 0 ? __scrollbar : new (0, _scrollbar.Scrollbar)();\n        this._render();\n    }\n    /**\n     * Destroys this feature. This function will be called by the carousel instance\n     * and should not be called manually.\n     * @internal\n     */ destroy() {\n        this._remove();\n        (0, _cache.clearFullCache)(this);\n    }\n    /**\n     * This triggers the feature to update its inner state. This function will be\n     * called by the carousel instance and should not be called manually. The\n     * carousel passes a event object that includes the update reason. This can be\n     * used to selectively/partially update sections of the feature.\n     * @internal\n     * @param event event that triggered the update\n     * @param event.reason is the update reason (why this was triggered)\n     */ update(event) {\n        switch(event.type){\n            case (0, _types.UpdateType).RESIZE:\n            case (0, _types.UpdateType).FORCED:\n                (0, _cache.clearCache)(this, CACHE_KEY_HEIGHT);\n                this._render();\n                break;\n            default:\n                this._render();\n                break;\n        }\n    }\n    /**\n     * Renders the mask element, wraps the carousel element and crops the\n     * height of the browsers scrollbar.\n     * @internal\n     */ _render() {\n        const { enabled, className, tagName } = (0, _cache.fromCache)(this, CACHE_KEY_CONFIGURATION);\n        if (!enabled) return;\n        const proxy = (0, _cache.fromCache)(this, CACHE_KEY_PROXY);\n        const element = proxy.el;\n        let { height } = __scrollbar.dimensions;\n        if (element.scrollWidth <= element.clientWidth) // If the contents are not scrollable because their width are less\n        // than the container, there will be no visible scrollbar. In this\n        // case, the scrollbar height is 0:\n        height = 0;\n        // Use fromCache factory to render mask element only once:\n        (0, _cache.fromCache)(this, CACHE_KEY_MASK, ()=>{\n            var _a;\n            const mask = document.createElement(tagName);\n            mask.className = className;\n            mask.style.overflow = \"hidden\";\n            mask.style.height = \"100%\";\n            (_a = element.parentNode) === null || _a === void 0 || _a.insertBefore(mask, element);\n            mask.appendChild(element);\n            return mask;\n        });\n        const cachedHeight = (0, _cache.fromCache)(this, CACHE_KEY_HEIGHT);\n        if (height === cachedHeight) return;\n        (0, _cache.writeCache)(this, CACHE_KEY_HEIGHT, height);\n        element.style.height = `calc(100% + ${height}px)`;\n        element.style.marginBottom = `${height * -1}px`;\n    }\n    /**\n     * Removes the mask element and unwraps the carousel element.\n     * @internal\n     */ _remove() {\n        var _a, _b;\n        const { el } = (0, _cache.fromCache)(this, CACHE_KEY_PROXY);\n        const mask = (0, _cache.fromCache)(this, CACHE_KEY_MASK);\n        (_a = mask === null || mask === void 0 ? void 0 : mask.parentNode) === null || _a === void 0 || _a.insertBefore(el, mask);\n        (_b = mask === null || mask === void 0 ? void 0 : mask.parentNode) === null || _b === void 0 || _b.removeChild(mask);\n        el.removeAttribute(\"style\");\n    }\n}\n\n},{\"../../types\":\"9eV98\",\"../../utils/cache\":\"032tB\",\"./scrollbar\":\"cK9wx\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"78Tkd\"}],\"9eV98\":[function(require,module,exports) {\n/**\n * Possible types of an update.\n */ var parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"UpdateType\", ()=>UpdateType);\nparcelHelpers.export(exports, \"ScrollBehavior\", ()=>ScrollBehavior);\nvar UpdateType;\n(function(UpdateType) {\n    UpdateType[\"SCROLL\"] = \"scroll\";\n    UpdateType[\"RESIZE\"] = \"resize\";\n    UpdateType[\"FORCED\"] = \"forced\";\n    UpdateType[\"FEATURE\"] = \"feature\";\n})(UpdateType || (UpdateType = {}));\nvar ScrollBehavior;\n(function(ScrollBehavior) {\n    ScrollBehavior[\"AUTO\"] = \"auto\";\n    ScrollBehavior[\"SMOOTH\"] = \"smooth\";\n})(ScrollBehavior || (ScrollBehavior = {}));\n\n},{\"@parcel/transformer-js/src/esmodule-helpers.js\":\"78Tkd\"}],\"78Tkd\":[function(require,module,exports) {\nexports.interopDefault = function(a) {\n    return a && a.__esModule ? a : {\n        default: a\n    };\n};\nexports.defineInteropFlag = function(a) {\n    Object.defineProperty(a, \"__esModule\", {\n        value: true\n    });\n};\nexports.exportAll = function(source, dest) {\n    Object.keys(source).forEach(function(key) {\n        if (key === \"default\" || key === \"__esModule\" || Object.prototype.hasOwnProperty.call(dest, key)) return;\n        Object.defineProperty(dest, key, {\n            enumerable: true,\n            get: function() {\n                return source[key];\n            }\n        });\n    });\n    return dest;\n};\nexports.export = function(dest, destName, get) {\n    Object.defineProperty(dest, destName, {\n        enumerable: true,\n        get: get\n    });\n};\n\n},{}],\"032tB\":[function(require,module,exports) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"fromCache\", ()=>fromCache);\n/**\n * Explicitly writes a value into the cache.\n * @typeParam T is the type of the value to cache\n * @param ref the reference\n * @param key the storage key\n * @param value the value\n */ parcelHelpers.export(exports, \"writeCache\", ()=>writeCache);\n/**\n * Creates the cache entry by as specific key of a given reference.\n * @param ref the reference\n * @param key the storage key\n */ parcelHelpers.export(exports, \"clearCache\", ()=>clearCache);\n/**\n * Clears the full cache by a given reference.\n * @param ref the reference.\n */ parcelHelpers.export(exports, \"clearFullCache\", ()=>clearFullCache);\nparcelHelpers.export(exports, \"cacheInstance\", ()=>cacheInstance);\nconst __CACHE = new WeakMap();\nfunction fromCache(ref, key, factory) {\n    const storage = __CACHE.get(ref) || new Map();\n    if (storage.has(key)) return storage.get(key);\n    if (!factory) return undefined;\n    const value = factory();\n    storage.set(key, value);\n    __CACHE.set(ref, storage);\n    return value;\n}\nfunction writeCache(ref, key, value) {\n    const storage = __CACHE.get(ref) || new Map();\n    storage.set(key, value);\n    __CACHE.set(ref, storage);\n}\nfunction clearCache(ref, key) {\n    const storage = __CACHE.get(ref);\n    if (!storage || !storage.has(key)) return;\n    storage.delete(key);\n}\nfunction clearFullCache(ref) {\n    __CACHE.delete(ref);\n}\nconst cacheInstance = null;\n\n},{\"@parcel/transformer-js/src/esmodule-helpers.js\":\"78Tkd\"}],\"cK9wx\":[function(require,module,exports) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\n/**\n * Helper class for scrollbar features.\n * @internal\n */ parcelHelpers.export(exports, \"Scrollbar\", ()=>Scrollbar);\nvar _cache = require(\"../../utils/cache\");\nconst CACHE_KEY_DIMENSIONS = \"dims\";\nclass Scrollbar {\n    /**\n     * Creates an instance.\n     * @internal\n     */ constructor(){\n        window.addEventListener(\"resize\", ()=>{\n            (0, _cache.clearCache)(this, CACHE_KEY_DIMENSIONS);\n        });\n    }\n    /**\n     * Calculates the dimensions of a scrollbar in the current browser. The result\n     * of the computation will be cached for this instance.\n     *\n     * Inspired by https://gist.github.com/kflorence/3086552\n     *\n     * @return the dimensions of the scrollar\n     */ get dimensions() {\n        return (0, _cache.fromCache)(this, CACHE_KEY_DIMENSIONS, ()=>{\n            const inner = document.createElement(\"div\");\n            const outer = document.createElement(\"div\");\n            document.body.appendChild(outer);\n            outer.style.position = \"absolute\";\n            outer.style.top = \"0px\";\n            outer.style.left = \"0px\";\n            outer.style.visibility = \"hidden\";\n            outer.appendChild(inner);\n            // Disabled, not needed for current feature set.\n            //\n            // Calculate width:\n            // inner.style.width = '100%';\n            // inner.style.height = '200px';\n            // outer.style.width = '200px';\n            // outer.style.height = '150px';\n            // outer.style.overflow = 'hidden';\n            // w1 = inner.offsetWidth;\n            // outer.style.overflow = 'scroll';\n            // w2 = inner.offsetWidth;\n            // w2 = (w1 === w2) ? outer.clientWidth : w2;\n            // width = w1 - w2;\n            // Calculate height:\n            inner.style.width = \"200px\";\n            inner.style.height = \"100%\";\n            outer.style.width = \"150px\";\n            outer.style.height = \"200px\";\n            outer.style.overflow = \"hidden\";\n            const h1 = inner.offsetHeight;\n            outer.style.overflow = \"scroll\";\n            let h2 = inner.offsetHeight;\n            h2 = h1 === h2 ? outer.clientHeight : h2;\n            const height = h1 - h2;\n            document.body.removeChild(outer);\n            return {\n                // width,\n                height\n            };\n        });\n    }\n}\n\n},{\"../../utils/cache\":\"032tB\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"78Tkd\"}],\"d3Dm4\":[function(require,module,exports) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\n/**\n * A proxy instance between carousel and a feature. Restricts the access for\n * features to the carousel instance.\n */ parcelHelpers.export(exports, \"Proxy\", ()=>Proxy);\nvar _types = require(\"./types\");\nvar _cache = require(\"./utils/cache\");\nconst CACHE_KEY_INSTANCE = \"inst\";\nconst CACHE_KEY_FEATURES = \"feat\";\n/**\n * Helper to access the instance cache.\n * @internal\n */ function __getInstance(ref) {\n    return (0, _cache.fromCache)(ref, CACHE_KEY_INSTANCE);\n}\n/**\n * Helper to access the features cache.\n * @internal\n */ function __getFeatures(ref) {\n    return (0, _cache.fromCache)(ref, CACHE_KEY_FEATURES);\n}\nclass Proxy {\n    /**\n     * Creates an instance of the proxy.\n     * @param instance the carousel instance to proxy the access to.\n     * @param features all the features that should access the carousel through this instance.\n     */ constructor(instance, features){\n        (0, _cache.writeCache)(this, CACHE_KEY_INSTANCE, instance);\n        (0, _cache.writeCache)(this, CACHE_KEY_FEATURES, features);\n    }\n    /**\n     * Proxies the {@link Carousel.id | `id`} getter of the carousel.\n     */ get id() {\n        return __getInstance(this).id;\n    }\n    /**\n     * Proxies the {@link Carousel.el | `el`} getter of the carousel.\n     */ get el() {\n        return __getInstance(this).el;\n    }\n    /**\n     * Proxies the {@link Carousel.mask | `mask`} getter of the carousel.\n     */ get mask() {\n        return __getInstance(this).mask;\n    }\n    /**\n     * Proxies the {@link Carousel.index | `index`} getter of the carousel.\n     */ get index() {\n        return __getInstance(this).index;\n    }\n    /**\n     * Proxies the {@link Carousel.index | `index`} setter of the carousel.\n     */ set index(value) {\n        __getInstance(this).index = value;\n    }\n    /**\n     * Proxies the {@link Carousel.items | `items`} getter of the carousel.\n     */ get items() {\n        return __getInstance(this).items;\n    }\n    /**\n     * Proxies the {@link Carousel.pages | `pages`} getter of the carousel.\n     */ get pages() {\n        return __getInstance(this).pages;\n    }\n    /**\n     * Proxies the {@link Carousel.pagesIndex | `pagesIndex`} getter of the carousel.\n     */ get pageIndex() {\n        return __getInstance(this).pageIndex;\n    }\n    /**\n     * Function to trigger an update from a feature. This will send an update to\n     * the carousel instance and all other attached features exept the sender.\n     * @param sender feature that triggers the update.\n     */ update(sender) {\n        __getInstance(this).update();\n        // Trigger update in all other features except the source feature that\n        // triggered the event:\n        __getFeatures(this).forEach((feature)=>{\n            if (feature === sender) return;\n            feature.update({\n                type: (0, _types.UpdateType).FEATURE\n            });\n        });\n    }\n}\n\n},{\"./types\":\"9eV98\",\"./utils/cache\":\"032tB\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"78Tkd\"}],\"5IcXl\":[function(require,module,exports) {\n// See: https://codeburst.io/throttling-and-debouncing-in-javascript-b01cad5c8edf\n/**\n * Creates a debounced version for a given function in a given delay (in ms).\n * @typeParam F is the shape of the function to debounce.\n * @param func the original function\n * @param delay the delay in milliseconds (ms)\n * @returns the debounced function\n */ var parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"debounce\", ()=>debounce);\nfunction debounce(func, delay) {\n    let timeout = null;\n    const debounced = (...args)=>{\n        if (timeout !== null) clearTimeout(timeout);\n        timeout = setTimeout(()=>func(...args), delay);\n    };\n    return debounced;\n}\n\n},{\"@parcel/transformer-js/src/esmodule-helpers.js\":\"78Tkd\"}],\"eanwb\":[function(require,module,exports) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\n/**\n * The feature to enable button controls (next and previous) for a carousel.\n */ parcelHelpers.export(exports, \"Buttons\", ()=>Buttons);\nvar _cache = require(\"../../utils/cache\");\nvar _render = require(\"../../utils/render\");\nvar __rest = undefined && undefined.__rest || function(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") {\n        for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n};\nconst FEATURE_NAME = \"buildin:buttons\";\nconst CACHE_KEY_PROXY = \"prxy\";\nconst CACHE_KEY_CONFIGURATION = \"conf\";\nconst CACHE_KEY_BUTTONS = \"btns\";\nconst EVENT_CLICK = \"click\";\nconst DEFAULTS = {\n    template: ({ className, controls, label, title })=>`\n\t\t<button type=\"button\" class=\"${className}\" aria-label=\"${label}\" title=\"${title}\" aria-controls=\"${controls}\">\n\t\t\t<span>${label}</span>\n\t\t</button>\n\t`,\n    className: \"button\",\n    nextClassName: \"is-next\",\n    nextLabel: \"Next\",\n    nextTitle: \"Go to next\",\n    previousClassName: \"is-previous\",\n    previousLabel: \"Previous\",\n    previousTitle: \"Go to previous\"\n};\nclass Buttons {\n    /**\n     * Creates an instance of this feature.\n     * @param options are the options to configure this instance\n     */ constructor(options = {}){\n        (0, _cache.writeCache)(this, CACHE_KEY_CONFIGURATION, Object.assign(Object.assign({}, DEFAULTS), options));\n        this._onPrev = this._onPrev.bind(this);\n        this._onNext = this._onNext.bind(this);\n    }\n    /**\n     * Returns the name of this feature.\n     */ get name() {\n        return FEATURE_NAME;\n    }\n    /**\n     * Initializes this feature. This function will be called by the carousel\n     * instance and should not be called manually.\n     * @internal\n     * @param proxy the proxy instance between carousel and feature\n     */ init(proxy) {\n        (0, _cache.writeCache)(this, CACHE_KEY_PROXY, proxy);\n        this._render();\n    }\n    /**\n     * Destroys this feature. This function will be called by the carousel instance\n     * and should not be called manually.\n     * @internal\n     */ destroy() {\n        this._remove();\n        (0, _cache.clearFullCache)(this);\n    }\n    /**\n     * This triggers the feature to update its inner state. This function will be\n     * called by the carousel instance and should not be called manually. The\n     * carousel passes a event object that includes the update reason. This can be\n     * used to selectively/partially update sections of the feature.\n     * @internal\n     */ update() {\n        this._render();\n    }\n    /**\n     * Renders and update the button elements. Buttons will only be rendered once\n     * and then loaded from cache. When calling this function twice or more, the\n     * button states will be updated based on the scroll position.\n     * @internal\n     */ _render() {\n        const proxy = (0, _cache.fromCache)(this, CACHE_KEY_PROXY);\n        const config = (0, _cache.fromCache)(this, CACHE_KEY_CONFIGURATION);\n        const { el, mask, pages, pageIndex } = proxy;\n        // Render buttons only once. Load them from cache if already rendered and\n        // attached to the dom:\n        const [next, previous] = (0, _cache.fromCache)(this, CACHE_KEY_BUTTONS, ()=>{\n            const target = mask !== null && mask !== void 0 ? mask : el;\n            const { template, className, previousClassName, previousLabel, previousTitle, nextClassName, nextLabel, nextTitle } = config;\n            // Create button elements:\n            const settings = [\n                {\n                    controls: el.id,\n                    label: nextLabel,\n                    title: nextTitle,\n                    className: [\n                        className,\n                        nextClassName\n                    ].join(\" \"),\n                    // The onClick listener is already bound in the constructor.\n                    //\n                    // eslint-disable-next-line @typescript-eslint/unbound-method\n                    handler: this._onNext\n                },\n                {\n                    controls: el.id,\n                    label: previousLabel,\n                    title: previousTitle,\n                    className: [\n                        className,\n                        previousClassName\n                    ].join(\" \"),\n                    // The onClick listener is already bound in the constructor.\n                    //\n                    // eslint-disable-next-line @typescript-eslint/unbound-method\n                    handler: this._onPrev\n                }\n            ];\n            return settings.map((_a)=>{\n                var _b;\n                var { handler } = _a, params = __rest(_a, [\n                    \"handler\"\n                ]);\n                const button = (0, _render.render)(template, params);\n                if (!button) return null;\n                button.addEventListener(EVENT_CLICK, handler);\n                (_b = target.parentNode) === null || _b === void 0 || _b.insertBefore(button, target.nextSibling);\n                return button;\n            });\n        });\n        if (next) {\n            const lastPage = pages[pageIndex + 1];\n            const isLastPage = lastPage === undefined;\n            next.disabled = isLastPage;\n        }\n        if (previous) {\n            const firstPage = pages[pageIndex - 1];\n            const isFirstPage = firstPage === undefined;\n            previous.disabled = isFirstPage;\n        }\n    }\n    /**\n     * Removes all buttons from the dom and detaches all event handler.\n     * @internal\n     */ _remove() {\n        const buttons = (0, _cache.fromCache)(this, CACHE_KEY_BUTTONS);\n        buttons === null || buttons === void 0 || buttons.forEach((button)=>{\n            var _a;\n            // The onClick listener is already bound in the constructor.\n            //\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            button === null || button === void 0 || button.removeEventListener(EVENT_CLICK, this._onPrev);\n            // The onClick listener is already bound in the constructor.\n            //\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            button === null || button === void 0 || button.removeEventListener(EVENT_CLICK, this._onNext);\n            (_a = button === null || button === void 0 ? void 0 : button.parentNode) === null || _a === void 0 || _a.removeChild(button);\n        });\n    }\n    /**\n     * Event handler to navigate backwards (to the left).\n     * @internal\n     */ _onPrev() {\n        const proxy = (0, _cache.fromCache)(this, CACHE_KEY_PROXY);\n        const { pages, pageIndex } = proxy;\n        const index = pages[pageIndex - 1] || pages[0];\n        proxy.index = index;\n    }\n    /**\n     * Event handler to navigate forwards (to the right).\n     * @internal\n     */ _onNext() {\n        const proxy = (0, _cache.fromCache)(this, CACHE_KEY_PROXY);\n        const { pages, pageIndex } = proxy;\n        const index = pages[pageIndex + 1] || pages[pages.length - 1];\n        proxy.index = index;\n    }\n}\n\n},{\"../../utils/cache\":\"032tB\",\"../../utils/render\":\"hnLDN\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"78Tkd\"}],\"hnLDN\":[function(require,module,exports) {\n/**\n * Renders a template (function) to into an HTML element. The template needs to\n * return a valid HTML string (with a single root element). A context with\n * key/value pairs will be passed into the template to allow dynamic rendering.\n * @typeParam El is the type of the rendered dom element.\n * @typeParam Context is the shape of the context data object\n * @param template a function to render a template\n * @param context context data for the template\n * @returns the rendered htmml element\n */ var parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"render\", ()=>render);\nfunction render(template, context) {\n    const el = document.createElement(\"div\");\n    el.innerHTML = template(context);\n    const ref = el.firstElementChild;\n    if (!ref) return null;\n    return ref;\n}\n\n},{\"@parcel/transformer-js/src/esmodule-helpers.js\":\"78Tkd\"}],\"qCeUm\":[function(require,module,exports) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\n/**\n * Feature to enable mouse controls\n */ parcelHelpers.export(exports, \"Mouse\", ()=>Mouse);\nvar _cache = require(\"../../utils/cache\");\nconst FEATURE_NAME = \"buildin:mouse\";\nconst CACHE_KEY_PROXY = \"prxy\";\nconst CACHE_KEY_CONFIGURATION = \"conf\";\nconst CACHE_KEY_PAGE_INDEX = \"pgidx\";\nconst CACHE_KEY_POSITION_X = \"posx\";\nconst CACHE_KEY_SCROLL_LEFT = \"scrl\";\nconst CACHE_KEY_TIMEOUT = \"time\";\nconst CURSOR_GRAB = \"grab\";\nconst CURSOR_GRABBING = \"grabbing\";\nconst EVENT_START = \"mousedown\";\nconst EVENT_DRAG = \"mousemove\";\nconst EVENT_END = \"mouseup\";\nconst THRESHOLD_MIN = 100;\nconst THRESHOLD_MAX = 250;\nconst THRESHOLD_FACTOR = 0.25; // Relative carousel element width\n// We are ignoring this due to this whole feature is only here to make TS happy.\n/* istanbul ignore next */ /**\n * Extracts the client x position from an event depending on the event type.\n * @internal\n * @param event the event\n * @returns the client x position\n */ function __getPositionX(event) {\n    if (event instanceof MouseEvent) return event.clientX;\n    return 0;\n}\nconst DEFAULTS = {\n    indicator: false\n};\nclass Mouse {\n    /**\n     * Creates an instance of this feature.\n     * @param options are the options to configure this instance\n     */ constructor(options = {}){\n        (0, _cache.writeCache)(this, CACHE_KEY_CONFIGURATION, Object.assign(Object.assign({}, DEFAULTS), options));\n        this._onStart = this._onStart.bind(this);\n        this._onDrag = this._onDrag.bind(this);\n        this._onEnd = this._onEnd.bind(this);\n    }\n    /**\n     * Returns the name of this feature.\n     */ get name() {\n        return FEATURE_NAME;\n    }\n    /**\n     * Initializes this feature. This function will be called by the carousel\n     * instance and should not be called manually.\n     * @internal\n     * @param proxy the proxy instance between carousel and feature\n     */ init(proxy) {\n        (0, _cache.writeCache)(this, CACHE_KEY_PROXY, proxy);\n        const config = (0, _cache.fromCache)(this, CACHE_KEY_CONFIGURATION);\n        const { el } = proxy;\n        const element = el;\n        element.style.cursor = config.indicator ? CURSOR_GRAB : \"\";\n        // The handler is already bound in the constructor.\n        //\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        el.addEventListener(EVENT_START, this._onStart, {\n            passive: true\n        });\n    }\n    /**\n     * Destroys this feature. This function will be called by the carousel instance\n     * and should not be called manually.\n     * @internal\n     */ destroy() {\n        (0, _cache.clearFullCache)(this);\n    }\n    /**\n     * This triggers the feature to update its inner state. This function will be\n     * called by the carousel instance and should not be called manually. The\n     * carousel passes a event object that includes the update reason. This can be\n     * used to selectively/partially update sections of the feature.\n     * @internal\n     */ update() {\n    /* nothing to update yet */ }\n    /**\n     * Handles the drag start event.\n     * @internal\n     * @param event the event that triggered the drag start\n     */ _onStart(event) {\n        var _a;\n        const timeout = (0, _cache.fromCache)(this, CACHE_KEY_TIMEOUT);\n        clearTimeout(timeout);\n        const config = (0, _cache.fromCache)(this, CACHE_KEY_CONFIGURATION);\n        const proxy = (0, _cache.fromCache)(this, CACHE_KEY_PROXY);\n        const element = proxy.el;\n        (0, _cache.fromCache)(this, CACHE_KEY_SCROLL_LEFT, ()=>element.scrollLeft);\n        (0, _cache.fromCache)(this, CACHE_KEY_POSITION_X, ()=>__getPositionX(event));\n        (0, _cache.fromCache)(this, CACHE_KEY_PAGE_INDEX, ()=>proxy.pageIndex);\n        // Reset scroll behavior and scroll snapping to emulate regular scrolling.\n        // Prevent user selection while the user drags:\n        element.style.userSelect = \"none\";\n        element.style.scrollBehavior = \"auto\";\n        element.style.scrollSnapType = \"none\";\n        element.style.cursor = config.indicator ? CURSOR_GRABBING : \"\";\n        // The handlers are already bound in the constructor.\n        //\n        /* eslint-disable @typescript-eslint/unbound-method */ window.addEventListener(EVENT_DRAG, this._onDrag, {\n            passive: true\n        });\n        window.addEventListener(EVENT_END, this._onEnd, {\n            passive: true\n        });\n        /* eslint-enable @typescript-eslint/unbound-method */ // Call the hook:\n        (_a = config.onStart) === null || _a === void 0 || _a.call(config, {\n            originalEvent: event\n        });\n    }\n    /**\n     * Handles the drag event. Calculates and updates scroll position.\n     * @internal\n     * @param event the event that triggered the dragging\n     */ _onDrag(event) {\n        var _a, _b, _c;\n        const config = (0, _cache.fromCache)(this, CACHE_KEY_CONFIGURATION);\n        const { el } = (0, _cache.fromCache)(this, CACHE_KEY_PROXY);\n        const left = (_a = (0, _cache.fromCache)(this, CACHE_KEY_SCROLL_LEFT)) !== null && _a !== void 0 ? _a : 0;\n        const x = (_b = (0, _cache.fromCache)(this, CACHE_KEY_POSITION_X)) !== null && _b !== void 0 ? _b : 0;\n        const currentX = __getPositionX(event);\n        const deltaX = x - currentX;\n        el.scrollLeft = left + deltaX;\n        // Call the hook:\n        (_c = config.onDrag) === null || _c === void 0 || _c.call(config, {\n            originalEvent: event\n        });\n    }\n    /**\n     * Handles the drag end event.\n     * @internal\n     * @param event the event that triggered the drag end\n     */ _onEnd(event) {\n        var _a, _b, _c, _d;\n        const proxy = (0, _cache.fromCache)(this, CACHE_KEY_PROXY);\n        const config = (0, _cache.fromCache)(this, CACHE_KEY_CONFIGURATION);\n        const left = (_a = (0, _cache.fromCache)(this, CACHE_KEY_SCROLL_LEFT)) !== null && _a !== void 0 ? _a : 0;\n        const pageIndex = (_b = (0, _cache.fromCache)(this, CACHE_KEY_PAGE_INDEX)) !== null && _b !== void 0 ? _b : 0;\n        (0, _cache.clearCache)(this, CACHE_KEY_SCROLL_LEFT);\n        (0, _cache.clearCache)(this, CACHE_KEY_POSITION_X);\n        (0, _cache.clearCache)(this, CACHE_KEY_PAGE_INDEX);\n        const element = proxy.el;\n        const threshold = Math.min(Math.max(THRESHOLD_MIN, element.clientWidth * THRESHOLD_FACTOR), THRESHOLD_MAX);\n        const currentLeft = element.scrollLeft;\n        const distance = currentLeft - left;\n        const offset = Math.abs(distance);\n        element.style.removeProperty(\"user-select\");\n        element.style.removeProperty(\"scroll-behavior\");\n        element.style.cursor = config.indicator ? CURSOR_GRAB : \"\";\n        // Apply the index. If the scroll offset is higher that the threshold,\n        // navigate to the next page depending on the drag direction.\n        let index = proxy.index;\n        if (offset > threshold) {\n            const direction = distance / offset;\n            const at = Math.max(pageIndex + direction, 0);\n            index = (_c = proxy.pages[at]) !== null && _c !== void 0 ? _c : index;\n        }\n        // Apply the index until the styles are rendered to the element. This is\n        // required to have a smooth scroll-behaviour which is disabled during the\n        // mouse dragging.\n        window.requestAnimationFrame(()=>{\n            proxy.index = index;\n        });\n        // Get around the scroll-snapping. Enable it until the position is already\n        // applied. This will take ~1000ms depending on distance and browser\n        // behaviour.\n        const timeout = window.setTimeout(()=>{\n            element.style.removeProperty(\"scroll-snap-type\");\n        }, 1000);\n        (0, _cache.writeCache)(this, CACHE_KEY_TIMEOUT, timeout);\n        // The handlers are already bound in the constructor.\n        //\n        /* eslint-disable @typescript-eslint/unbound-method */ window.removeEventListener(EVENT_DRAG, this._onDrag);\n        window.removeEventListener(EVENT_END, this._onEnd);\n        /* eslint-enable @typescript-eslint/unbound-method */ // Call the hook:\n        (_d = config.onEnd) === null || _d === void 0 || _d.call(config, {\n            originalEvent: event\n        });\n    }\n}\n\n},{\"../../utils/cache\":\"032tB\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"78Tkd\"}],\"hUskH\":[function(require,module,exports) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\n/**\n * The feature to enable pagination controls.\n */ parcelHelpers.export(exports, \"Pagination\", ()=>Pagination);\nvar _types = require(\"../../types\");\nvar _cache = require(\"../../utils/cache\");\nvar _render = require(\"../../utils/render\");\nconst FEATURE_NAME = \"buildin:pagination\";\nconst CACHE_KEY_PROXY = \"prxy\";\nconst CACHE_KEY_CONFIGURATION = \"conf\";\nconst CACHE_KEY_PAGINATION = \"pags\";\nconst CACHE_KEY_BUTTONS = \"btns\";\nconst DEFAULTS = {\n    // @TODO: ESLint don't like the nested template literals and loops.\n    /* eslint-disable indent */ template: ({ className, controls, pages, label, title })=>`\n\t\t<ul class=\"${className}\">\n\t\t\t${pages.map((page, index)=>{\n            const data = {\n                index,\n                page,\n                pages\n            };\n            const labelStr = label(data);\n            const titleStr = title(data);\n            return `<li>\n\t\t\t\t\t<button type=\"button\" aria-controls=\"${controls}\" aria-label=\"${titleStr}\" title=\"${titleStr}\">\n\t\t\t\t\t\t<span>${labelStr}</span>\n\t\t\t\t\t</button>\n\t\t\t\t</li>`;\n        }).join(\"\")}\n\t\t</ul>\n\t`,\n    /* eslint-enable indent */ className: \"pagination\",\n    label: ({ index })=>`${index + 1}`,\n    title: ({ index })=>`Go to ${index + 1}. page`\n};\nclass Pagination {\n    /**\n     * Creates an instance of this feature.\n     * @param options are the options to configure this instance\n     */ constructor(options = {}){\n        (0, _cache.writeCache)(this, CACHE_KEY_CONFIGURATION, Object.assign(Object.assign({}, DEFAULTS), options));\n        this._onClick = this._onClick.bind(this);\n    }\n    /**\n     * Returns the name of this feature.\n     */ get name() {\n        return FEATURE_NAME;\n    }\n    /**\n     * Initializes this feature. This function will be called by the carousel\n     * instance and should not be called manually.\n     * @internal\n     * @param proxy the proxy instance between carousel and feature\n     */ init(proxy) {\n        (0, _cache.writeCache)(this, CACHE_KEY_PROXY, proxy);\n        this._add();\n    }\n    /**\n     * Destroys this feature. This function will be called by the carousel instance\n     * and should not be called manually.\n     * @internal\n     */ destroy() {\n        this._remove();\n        (0, _cache.clearFullCache)(this);\n    }\n    /**\n     * This triggers the feature to update its inner state. This function will be\n     * called by the carousel instance and should not be called manually. The\n     * carousel passes a event object that includes the update reason. This can be\n     * used to selectively/partially update sections of the feature.\n     * @internal\n     * @param event event that triggered the update\n     * @param event.type is the update reason (why this was triggered)\n     */ update(event) {\n        switch(event.type){\n            case (0, _types.UpdateType).SCROLL:\n                this._update();\n                break;\n            default:\n                this._remove();\n                this._add();\n                break;\n        }\n    }\n    /**\n     * Renders and adds the pagination element. Attaches event handlers to all\n     * button elements.\n     * @internal\n     */ _add() {\n        var _a;\n        const proxy = (0, _cache.fromCache)(this, CACHE_KEY_PROXY);\n        const config = (0, _cache.fromCache)(this, CACHE_KEY_CONFIGURATION);\n        const { el, mask, pages } = proxy;\n        const target = mask !== null && mask !== void 0 ? mask : el;\n        if (pages.length < 2) return;\n        const { template, className, label, title } = config;\n        const pagination = (0, _render.render)(template, {\n            label,\n            title,\n            pages,\n            className,\n            controls: el.id\n        });\n        if (!pagination) return;\n        // @TODO: Add template for buttons:\n        const buttons = Array.from(pagination.querySelectorAll(\"button\")).map((button)=>{\n            // The onClick listener is already bound in the constructor.\n            //\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            button.addEventListener(\"click\", this._onClick, true);\n            return button;\n        });\n        (_a = target.parentNode) === null || _a === void 0 || _a.appendChild(pagination);\n        (0, _cache.writeCache)(this, CACHE_KEY_PAGINATION, pagination);\n        (0, _cache.writeCache)(this, CACHE_KEY_BUTTONS, buttons);\n        this._update();\n    }\n    /**\n     * Updates the states of all buttons inside the pagination.\n     * @internal\n     */ _update() {\n        const proxy = (0, _cache.fromCache)(this, CACHE_KEY_PROXY);\n        const buttons = (0, _cache.fromCache)(this, CACHE_KEY_BUTTONS);\n        const { pageIndex } = proxy;\n        buttons === null || buttons === void 0 || buttons.forEach((button, at)=>button.disabled = at === pageIndex);\n    }\n    /**\n     * Removes the whole pagination element and removes all attached event handlers.\n     * @internal\n     */ _remove() {\n        var _a;\n        const pagination = (0, _cache.fromCache)(this, CACHE_KEY_PAGINATION);\n        const buttons = (0, _cache.fromCache)(this, CACHE_KEY_BUTTONS);\n        buttons === null || buttons === void 0 || buttons.forEach((button)=>{\n            var _a;\n            // The onClick listener is already bound in the constructor.\n            //\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            button.removeEventListener(\"click\", this._onClick);\n            (_a = button.parentNode) === null || _a === void 0 || _a.removeChild(button);\n        });\n        (_a = pagination === null || pagination === void 0 ? void 0 : pagination.parentNode) === null || _a === void 0 || _a.removeChild(pagination);\n        (0, _cache.clearCache)(this, CACHE_KEY_BUTTONS);\n        (0, _cache.clearCache)(this, CACHE_KEY_PAGINATION);\n    }\n    /**\n     * Event handler when a button is clicked. Detects the current index of the\n     * clicked button inside the pagination and updates the index accordingly of\n     * the carousel.\n     * @internal\n     * @param event the mouse event\n     */ _onClick(event) {\n        const proxy = (0, _cache.fromCache)(this, CACHE_KEY_PROXY);\n        const buttons = (0, _cache.fromCache)(this, CACHE_KEY_BUTTONS);\n        if (!buttons) return;\n        const target = event.currentTarget;\n        const index = buttons.indexOf(target);\n        proxy.index = proxy.pages[index];\n    }\n}\n\n},{\"../../types\":\"9eV98\",\"../../utils/cache\":\"032tB\",\"../../utils/render\":\"hnLDN\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"78Tkd\"}]},[], null, \"parcelRequireec03\")\n\n//# sourceMappingURL=index.e0123caa.js.map\n","import { Mask } from './features/mask';\nimport { Proxy } from './proxy';\nimport { FilterItemFn, ICarousel, IFeature, Index, Pages, ScrollBehavior, ScrollHook, UpdateType } from './types';\nimport { clearCache, clearFullCache, fromCache, writeCache } from './utils/cache';\nimport { debounce } from './utils/debounce';\n\n\nconst ID_NAME = (count: number) => `caroucssel-${count}`;\nconst ID_MATCH = /^caroucssel-[0-9]*$/;\n\nconst EVENT_SCROLL = 'scroll';\nconst EVENT_RESIZE = 'resize';\n\nconst CACHE_KEY_ELEMENT = 'element';\nconst CACHE_KEY_ID = 'id';\nconst CACHE_KEY_CONFIGURATION = 'config';\nconst CACHE_KEY_INDEX = 'index';\nconst CACHE_KEY_ITEMS = 'items';\nconst CACHE_KEY_PAGES = 'pages';\nconst CACHE_KEY_PAGE_INDEX = 'page-index';\nconst CACHE_KEY_MASK = 'mask';\nconst CACHE_KEY_PROXY = 'proxy';\nconst CACHE_KEY_FEATURES = 'feautres';\n\nconst VISIBILITY_OFFSET = 0.25;\nconst INVISIBLE_ELEMENTS = /^(link|meta|noscript|script|style|title)$/i;\n\n\n/**\n * Export the mask because it's used by default inside the carousel.\n */\nexport { Mask };\n\n\n/**\n * The available options for the carousel.\n */\nexport type Options = {\n\tindex?: Index | number;\n\tfeatures?: IFeature[],\n\tfilterItem?: FilterItemFn;\n\tonScroll?: ScrollHook;\n};\n\n\n/**\n * The required configuration of the carousel.\n * @internal\n */\nexport type Configuration = Omit<Required<Options>, 'index'>;\n\n\n/*\n * Internal counter for created instances. Will be used to create unique IDs.\n */\nlet __instanceCount = 0;\n\n\nconst DEFAULTS: Configuration = {\n\tfeatures: [],\n\tfilterItem: () => true,\n\tonScroll: () => undefined,\n};\n\n\n/**\n * The carousel instance.\n */\nexport class Carousel implements ICarousel {\n\n\t/**\n\t * This will be used for testing purposes to reset the instance count which is\n\t * used to create unique id's.\n\t * @internal\n\t */\n\tpublic static resetInstanceCount(): void {\n\t\t/* This should not be part of the coverage report: test util */\n\t\t/* istanbul ignore next */\n\t\tif (process.env.NODE_ENV === 'test') {\n\t\t\t__instanceCount = 0;\n\t\t}\n\t}\n\n\t/**\n\t * Current scroll behavior. Possible values are:\n\t * * `'auto'`\n\t * * `'smooth'`\n\t */\n\tpublic behavior: ScrollBehavior = ScrollBehavior.AUTO;\n\n\t/**\n\t * Creates an instance.\n\t * @param el is the dom element to control. This should be a container element\n\t * \tthat holds child elements that will scroll horizontally.\n\t * @param options are the options to configure this instance.\n\t */\n\tconstructor(el: Element, options: Options = {}) {\n\t\tif (!el || !(el instanceof Element)) {\n\t\t\tthrow new Error(`Carousel needs a dom element but \"${(typeof el)}\" was passed.`);\n\t\t}\n\n\t\twriteCache(this, CACHE_KEY_ELEMENT, el);\n\n\t\t// Count all created instances to create unique id, if given dom element\n\t\t// has no id-attribute:\n\t\t__instanceCount++;\n\t\tel.id = el.id || ID_NAME(__instanceCount);\n\t\twriteCache(this, CACHE_KEY_ID, el.id);\n\n\t\t// Extend options and defaults into configuration:\n\t\tconst configuration = { ...DEFAULTS, ...options };\n\t\twriteCache(this, CACHE_KEY_CONFIGURATION, configuration);\n\n\t\t// Detect if there is a \"Mask\" feature passed as option. Then use this one,\n\t\t// otherwise add a mandatory instance by default. Also ensure that only one\n\t\t// feature of type \"Mask\" is in the features list.\n\t\tlet mask: IFeature | null = null;\n\t\tlet features = [...configuration.features];\n\t\tconst index = configuration.features.findIndex((feature): boolean => feature instanceof Mask);\n\t\tif (index > -1) {\n\t\t\t// Extract first found instance of \"Mask\":\n\t\t\t[mask] = features.splice(index, 1);\n\t\t}\n\t\tmask ??= new Mask();\n\t\tfeatures = features.filter((feature): boolean => !(feature instanceof Mask));\n\t\tfeatures = [mask, ...features];\n\t\twriteCache(this, CACHE_KEY_MASK, mask);\n\n\t\t// Features: Initialize all features with a single proxy instance inbetween.\n\t\tconst proxy = new Proxy(this, features);\n\t\twriteCache(this, CACHE_KEY_PROXY, proxy);\n\t\twriteCache(this, CACHE_KEY_FEATURES, features);\n\t\tfeatures.forEach((feature) => feature.init(proxy));\n\n\t\t// Set initial index and finally set smooth scrolling to enabled:\n\t\tswitch (true) {\n\t\t\t// When index is a list:\n\t\t\tcase Array.isArray(options.index):\n\t\t\t\tthis.index = options.index as Index;\n\t\t\t\tbreak;\n\n\t\t\t// When index is a number, transfrom to list:\n\t\t\tcase !isNaN(options.index as number):\n\t\t\t\tthis.index = [options.index as number];\n\t\t\t\tbreak;\n\t\t}\n\t\tthis.behavior = ScrollBehavior.SMOOTH;\n\n\t\t// Debounced events:\n\t\t//\n\t\t// Where do these magic numbers come from? The numbers are the results of\n\t\t// testing the behavior in several browsers and are considered at \"best fit\"\n\t\t// without visible side effects to the UI. The value for the \"scroll\" event\n\t\t// correlates with the timing of scroll-behaviour: smooth.\n\t\t//\n\t\t// We disable @typescript-eslint/unbound-method here because we already bound\n\t\t// the functions while creating a debounced version. This would also cause\n\t\t// reference errors when tying to access these function references when used\n\t\t// with removeEventListeners() (see: destroy())\n\t\t//\n\t\t/* eslint-disable @typescript-eslint/unbound-method */\n\t\tthis._onScroll = debounce(this._onScroll.bind(this), 45);\n\t\tthis._onResize = debounce(this._onResize.bind(this), 25);\n\t\tel.addEventListener(EVENT_SCROLL, this._onScroll);\n\t\twindow.addEventListener(EVENT_RESIZE, this._onResize);\n\t\t/* eslint-enable @typescript-eslint/unbound-method */\n\t}\n\n\t/**\n\t * Returns the dom element reference of the carousel which was passed into the\n\t * constructor.\n\t * @public\n\t * @return the controlled dom element\n\t */\n\tpublic get el(): Element {\n\t\treturn fromCache<Element>(this, CACHE_KEY_ELEMENT) as Element;\n\t}\n\n\t/**\n\t * Returns the dom element reference of the mask element that wraps the\n\t * carousel element.\n\t * @public\n\t * @return the mask dom element\n\t */\n\tpublic get mask(): Element | null {\n\t\tconst mask = fromCache<Mask>(this, CACHE_KEY_MASK) as Mask;\n\t\treturn mask.el ?? null;\n\t}\n\n\t/**\n\t * Returns the id-attribute value of the carousel.\n\t * @public\n\t * @return the id of the controlled dom element\n\t */\n\tpublic get id(): string {\n\t\treturn fromCache<string>(this, CACHE_KEY_ID) as string;\n\t}\n\n\t/**\n\t * Returns the current index of the carousel. The returned index is a list (array)\n\t * of indexes that are currently visible (depending on each item width).\n\t * @public\n\t * @return a list of visible indexes\n\t */\n\tpublic get index(): Index {\n\t\treturn fromCache(this, CACHE_KEY_INDEX, (): Index => {\n\t\t\tconst { el, items } = this;\n\t\t\tconst { length } = items;\n\t\t\tconst { clientWidth } = el;\n\t\t\tconst outerLeft = el.getBoundingClientRect().left;\n\n\t\t\tconst index: number[] = [];\n\t\t\tlet at = 0;\n\n\t\t\tfor (;at < length; at++) {\n\t\t\t\tconst item = items[at];\n\t\t\t\tconst rect = item.getBoundingClientRect();\n\t\t\t\tconst { width } = rect;\n\t\t\t\tlet { left } = rect;\n\t\t\t\tleft = left - outerLeft;\n\n\t\t\t\tif (left + width * VISIBILITY_OFFSET >= 0 &&\n\t\t\t\t\tleft + width * (1 - VISIBILITY_OFFSET) <= clientWidth) {\n\t\t\t\t\tindex.push(at);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (index.length === 0) {\n\t\t\t\t// If no index found, we return a [0] as default. This possibly happens\n\t\t\t\t// when the carousel is not attached to the DOM or is visually hidden (display: none).\n\t\t\t\treturn [0];\n\t\t\t}\n\n\t\t\treturn index as Index;\n\t\t});\n\t}\n\n\t/**\n\t * Sets the current index of the carousel. To set an index you need to pass an\n\t * array with at least one element. When passing more than one, the rest will\n\t * be ignored.\n\t * @public\n\t * @param values are the upcoming indexes\n\t */\n\tpublic set index(values: Index) {\n\t\tconst { behavior, el, items } = this;\n\t\tconst { length } = items;\n\n\t\tif (!Array.isArray(values) || !values.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet value = values[0] || 0;\n\t\tvalue = Math.max(Math.min(value, length - 1), 0);\n\n\t\tconst { scrollLeft } = el;\n\t\tconst from = { left: scrollLeft };\n\t\tconst to = { left: items[value].offsetLeft };\n\n\t\t// If the target item is the first visible element in the list, ignore\n\t\t// the possible offset to the left and scroll to the beginning of the list:\n\t\tif (value === this.pages[0][0]) {\n\t\t\tto.left = 0;\n\t\t}\n\n\t\tif (from.left === to.left) {\n\t\t\treturn;\n\t\t}\n\n\t\tclearCache(this, CACHE_KEY_INDEX);\n\n\t\tel.scrollTo({ ...to, behavior });\n\t}\n\n\t/**\n\t * Returns an array of all child dom elements of the carousel.\n\t * @public\n\t * @return a list of elements (child elements of the root element)\n\t */\n\tpublic get items(): HTMLElement[] {\n\t\treturn fromCache(this, CACHE_KEY_ITEMS, (): HTMLElement[] => {\n\t\t\tconst { filterItem } = fromCache<Configuration>(this, CACHE_KEY_CONFIGURATION) as Configuration;\n\t\t\tconst { el } = this;\n\t\t\tconst children = Array.from(el.children) as HTMLElement[];\n\n\t\t\treturn children\n\t\t\t\t.filter((item) => !INVISIBLE_ELEMENTS.test(item.tagName) && !item.hidden)\n\t\t\t\t.filter(filterItem);\n\t\t});\n\t}\n\n\t/**\n\t * Returns an array of all pages. Each page is a group of indexes that matches\n\t * a page.\n\t * @public\n\t * @return the list of pages and indexes inside each page\n\t */\n\tpublic get pages(): Pages {\n\t\treturn fromCache(this, CACHE_KEY_PAGES, (): Pages => {\n\t\t\tconst { el, items } = this;\n\t\t\tconst { clientWidth: viewport } = el;\n\n\t\t\tif (viewport === 0) {\n\t\t\t\t// if the width of the carousel element is zero, we can not calculate\n\t\t\t\t// the pages properly and the carousel seems to be not visible. If\n\t\t\t\t// this is the case, we assume that each item is placed on a\n\t\t\t\t// separate page.\n\t\t\t\treturn items.map((item, index) => [index] as Index) as Pages;\n\t\t\t}\n\n\t\t\ttype Dataset = {\n\t\t\t\titem: HTMLElement;\n\t\t\t\tleft: number;\n\t\t\t\twidth: number;\n\t\t\t\tindex: number;\n\t\t\t};\n\n\t\t\tlet pages: Dataset[][] = [[]];\n\n\t\t\titems\n\t\t\t\t.map((item, index): Dataset => {\n\t\t\t\t\t// Create a re-usable dataset for each item:\n\t\t\t\t\tconst { offsetLeft: left, clientWidth: width } = item;\n\t\t\t\t\treturn { left, width, item, index };\n\t\t\t\t})\n\t\t\t\t.sort((a, b) => {\n\t\t\t\t\t// Create ordered list of items based on their visual ordering.\n\t\t\t\t\t// This may differ from the DOM ordering unsing css properties\n\t\t\t\t\t// like `order` in  flexbox or grid:\n\t\t\t\t\treturn a.left - b.left;\n\t\t\t\t})\n\t\t\t\t.forEach((item) => {\n\t\t\t\t\t// Calculate pages / page indexes for each item:\n\t\t\t\t\t//\n\t\t\t\t\t// The idea behind the calculation of the pages is to separate\n\t\t\t\t\t// the items by fitting them into the viewport of the carousel.\n\t\t\t\t\t// To behave correctly, we cannot divide the total length of the\n\t\t\t\t\t// carousel by the viewport to get the page indexes (naive approach).\n\t\t\t\t\t// However, since there may be items that are partially visible\n\t\t\t\t\t// on a page, but mathematically create a new page. The calculation\n\t\t\t\t\t// must start from this item again. This means that always the\n\t\t\t\t\t// first item on a page sets the basis for the calculation of\n\t\t\t\t\t// the following item and its belonging to the current or next\n\t\t\t\t\t// page:\n\t\t\t\t\tconst { left, width } = item;\n\n\t\t\t\t\tconst prevPage = pages[pages.length - 1];\n\t\t\t\t\tconst firstItem = prevPage[0];\n\t\t\t\t\tlet start = firstItem?.left || 0;\n\n\t\t\t\t\t// This is required for the first page. The first page always\n\t\t\t\t\t// needs to start from the left=0. Any offset from the\n\t\t\t\t\t// left of the first visual item needs to be ignored, otherwise\n\t\t\t\t\t// the calculation of visual pages is incorrect:\n\t\t\t\t\tif (prevPage === pages[0]) {\n\t\t\t\t\t\tstart = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\t// At least 75% of the items needs to be in the page. Calculate\n\t\t\t\t\t// the amount of new pages to add. If value is 0, the current\n\t\t\t\t\t// item fits into the previous page:\n\t\t\t\t\tlet add = Math.floor(((left - start) + width * (1 - VISIBILITY_OFFSET)) / viewport);\n\n\t\t\t\t\twhile(add > 0) {\n\t\t\t\t\t\tpages.push([]);\n\t\t\t\t\t\tadd--;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst page = pages[pages.length - 1];\n\t\t\t\t\tpage.push(item);\n\t\t\t\t});\n\n\t\t\t// Remove empty pages: this might happen if items are wider than the\n\t\t\t// carousel viewport:\n\t\t\tpages = pages.filter((page) => page.length !== 0);\n\n\t\t\t// Restructure pages to only contain the index of each item:\n\t\t\treturn pages.map((page) => page.map(({ index }) => index) as Index) as Pages;\n\t\t});\n\t}\n\n\t/**\n\t * Returns the index of the current page.\n\t * @public\n\t * @return the index of the current page\n\t */\n\tpublic get pageIndex(): number {\n\t\treturn fromCache(this, CACHE_KEY_PAGE_INDEX, (): number => {\n\t\t\tconst { el, items, index, pages } = this;\n\t\t\tconst outerLeft = el.getBoundingClientRect().left;\n\t\t\tconst { clientWidth } = el;\n\n\t\t\tlet visibles: number[] = index.reduce<number []>((acc, at) => {\n\t\t\t\tif (!items[at]) {\n\t\t\t\t\treturn acc;\n\t\t\t\t}\n\n\t\t\t\tlet { left, right } = items[at].getBoundingClientRect();\n\t\t\t\t// \"getBoundingClientRect()\" can return float numbers which\n\t\t\t\t// lead to an unwanted behavior when in the calculation with\n\t\t\t\t// \"clientWidth\" (not using floats). We use round here to\n\t\t\t\t// normalize those values...\n\t\t\t\tleft = Math.round(left - outerLeft);\n\t\t\t\tright = Math.round(right - outerLeft);\n\n\t\t\t\t// Remove items that partially hidden to the left or right:\n\t\t\t\tif (left < 0 || clientWidth < right) {\n\t\t\t\t\treturn acc;\n\t\t\t\t}\n\n\t\t\t\treturn acc.concat([at]);\n\t\t\t}, []);\n\n\t\t\t// There might be no possible candidates. This is the case when items\n\t\t\t// are wider than the element viewport. In this case we take the first\n\t\t\t// item which is currently visible in general (might be the only one):\n\t\t\tif (visibles.length === 0) {\n\t\t\t\tvisibles = [index[0]];\n\t\t\t}\n\n\t\t\t// Search for the visible item that is most aligned to the right. The\n\t\t\t// found item marks the current page...\n\t\t\tconst at = visibles.sort((a, b) => {\n\t\t\t\tconst rightA = items[a].getBoundingClientRect().right;\n\t\t\t\tconst rightB = items[b].getBoundingClientRect().right;\n\t\t\t\treturn rightB - rightA;\n\t\t\t})[0];\n\n\t\t\t// Find the page index where the current item index is located...\n\t\t\treturn pages.findIndex((page) => page.includes(at));\n\t\t});\n\t}\n\n\t/**\n\t * This completely deconstructs the carousel and returns the dom to its\n\t * initial state.\n\t * @public\n\t */\n\tpublic destroy(): void {\n\t\tconst { el } = this;\n\n\t\t// Remove created id if it was created by carousel:\n\t\tID_MATCH.test(el.id) && el.removeAttribute('id');\n\n\t\t// Destroy attached features:\n\t\tconst features = fromCache<IFeature[]>(this, CACHE_KEY_FEATURES) as IFeature[];\n\t\tfeatures.forEach((feature) => feature.destroy());\n\n\t\t// Remove events:\n\t\t//\n\t\t// We need to work the the function reference. Using .bind() would create a\n\t\t// new referenced instance of the callback function. We already created a\n\t\t// bound version of these function within the constructor.\n\t\t//\n\t\t/* eslint-disable @typescript-eslint/unbound-method */\n\t\tel.removeEventListener(EVENT_SCROLL, this._onScroll);\n\t\twindow.removeEventListener(EVENT_RESIZE, this._onResize);\n\t\t/* eslint-enable @typescript-eslint/unbound-method */\n\n\t\t// Clear cache:\n\t\tclearFullCache(this);\n\t}\n\n\t/**\n\t * Enforces an update of all enabled components of the carousel. This is, for\n\t * example, useful when changing the number of items inside the carousel. This\n\t * also forwards an update call to all attached features.\n\t * @public\n\t */\n\tpublic update(): void {\n\t\tclearCache(this, CACHE_KEY_INDEX);\n\t\tclearCache(this, CACHE_KEY_ITEMS);\n\t\tclearCache(this, CACHE_KEY_PAGES);\n\t\tclearCache(this, CACHE_KEY_PAGE_INDEX);\n\n\t\tconst features = fromCache<IFeature[]>(this, CACHE_KEY_FEATURES) as IFeature[];\n\t\tfeatures.forEach((feature) => feature.update({ type: UpdateType.FORCED }));\n\t}\n\n\tprotected _onScroll(event: Event): void {\n\t\tclearCache(this, CACHE_KEY_INDEX);\n\t\tclearCache(this, CACHE_KEY_PAGE_INDEX);\n\n\t\tconst features = fromCache<IFeature[]>(this, CACHE_KEY_FEATURES) as IFeature[];\n\t\tfeatures.forEach((feature) => feature.update({ type: UpdateType.SCROLL }));\n\n\t\tconst { index } = this;\n\t\tconst configuration = fromCache<Configuration>(this, CACHE_KEY_CONFIGURATION) as Configuration;\n\t\tconfiguration.onScroll<Carousel>({ index, type: EVENT_SCROLL, target: this, originalEvent: event });\n\t}\n\n\tprotected _onResize(): void {\n\t\tclearCache(this, CACHE_KEY_PAGES);\n\t\tclearCache(this, CACHE_KEY_INDEX);\n\t\tclearCache(this, CACHE_KEY_PAGE_INDEX);\n\n\t\tconst features = fromCache<IFeature[]>(this, CACHE_KEY_FEATURES) as IFeature[];\n\t\tfeatures.forEach((feature) => feature.update({ type: UpdateType.RESIZE }));\n\t}\n\n}\n","import { IFeature, IProxy, UpdateEvent, UpdateType } from '../../types';\nimport { clearCache, clearFullCache, fromCache, writeCache } from '../../utils/cache';\n\nimport { Scrollbar } from './scrollbar';\n\n\nconst FEATURE_NAME = 'buildin:mask';\n\nconst CACHE_KEY_PROXY = 'prxy';\nconst CACHE_KEY_CONFIGURATION = 'conf';\nconst CACHE_KEY_MASK = 'mask';\nconst CACHE_KEY_HEIGHT = 'hght';\n\n\n/**\n * The options for the mask and scrollbar features.\n */\nexport type Options = {\n\n\t/**\n\t * Enables/disables the rendering of the mask to hide (enabled) or show\n\t * (disabled) the browsers scrollbars.\n\t * @defaultValue `true`\n\t */\n\tenabled?: boolean;\n\n\t/**\n\t * The class name of the mask element that will wrap the carousel element.\n\t * @defaultValue `'caroucssel-mask'`\n\t */\n\tclassName?: string;\n\n\t/**\n\t * The tag name of the mask element that will wrap the carousel element.\n\t * @defaultValue `'div'`\n\t */\n\ttagName?: string;\n\n};\n\n\n/**\n * The required configuration for mask and scrollbar features.\n * @internal\n */\ntype Configuration = Required<Options>;\n\n\n/**\n * Singleton of scrollbar util. Is shared across all instances of carousel to\n * reduce redundant calculations.\n * @internal\n */\nlet __scrollbar: Scrollbar;\n\n\nconst DEFAULTS: Configuration = {\n\tenabled: true,\n\tclassName: 'caroucssel-mask',\n\ttagName: 'div',\n};\n\n\n/**\n * The feature to enable/disabled mask and scrollbar support. This feature will\n * be added by default to each carousel. Use this feature to customize the\n * default behaviour.\n */\nexport class Mask implements IFeature {\n\n\t/**\n\t * Creates an instance of this feature.\n\t * @param options are the options to configure this instance\n\t */\n\tconstructor(options: Options = {}) {\n\t\twriteCache(this, CACHE_KEY_CONFIGURATION, { ...DEFAULTS, ...options });\n\t}\n\n\t/**\n\t * Returns the name of this feature.\n\t */\n\tpublic get name(): typeof FEATURE_NAME {\n\t\treturn FEATURE_NAME;\n\t}\n\n\t/**\n\t * Returns the rendered element that wraps the carousel. If not enabled, this\n\t * returns `null`.\n\t * @return the mask element, otherwise `null` if disabled.\n\t */\n\tpublic get el(): Element | null {\n\t\treturn fromCache<Element>(this, CACHE_KEY_MASK) ?? null;\n\t}\n\n\t/**\n\t * Initializes this feature. This function will be called by the carousel\n\t * instance and should not be called manually.\n\t * @internal\n\t * @param proxy the proxy instance between carousel and feature\n\t */\n\tpublic init(proxy: IProxy): void {\n\t\twriteCache(this, CACHE_KEY_PROXY, proxy);\n\n\t\t// Create a singleton instance of scrollbar for all carousel instances:\n\t\t__scrollbar = __scrollbar ?? new Scrollbar();\n\n\t\tthis._render();\n\t}\n\n\t/**\n\t * Destroys this feature. This function will be called by the carousel instance\n\t * and should not be called manually.\n\t * @internal\n\t */\n\tpublic destroy(): void {\n\t\tthis._remove();\n\t\tclearFullCache(this);\n\t}\n\n\t/**\n\t * This triggers the feature to update its inner state. This function will be\n\t * called by the carousel instance and should not be called manually. The\n\t * carousel passes a event object that includes the update reason. This can be\n\t * used to selectively/partially update sections of the feature.\n\t * @internal\n\t * @param event event that triggered the update\n\t * @param event.reason is the update reason (why this was triggered)\n\t */\n\tpublic update(event: UpdateEvent): void {\n\t\tswitch (event.type) {\n\t\t\tcase UpdateType.RESIZE:\n\t\t\tcase UpdateType.FORCED:\n\t\t\t\tclearCache(this, CACHE_KEY_HEIGHT);\n\t\t\t\tthis._render();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthis._render();\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * Renders the mask element, wraps the carousel element and crops the\n\t * height of the browsers scrollbar.\n\t * @internal\n\t */\n\tprivate _render(): void {\n\t\tconst { enabled, className, tagName } = fromCache<Configuration>(this, CACHE_KEY_CONFIGURATION) as Configuration;\n\t\tif (!enabled) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst proxy = fromCache<IProxy>(this, CACHE_KEY_PROXY) as IProxy;\n\t\tconst element = proxy.el as HTMLElement | SVGElement;\n\t\tlet { height } = __scrollbar.dimensions;\n\n\t\tif (element.scrollWidth <= element.clientWidth) {\n\t\t\t// If the contents are not scrollable because their width are less\n\t\t\t// than the container, there will be no visible scrollbar. In this\n\t\t\t// case, the scrollbar height is 0:\n\t\t\theight = 0;\n\t\t}\n\n\t\t// Use fromCache factory to render mask element only once:\n\t\tfromCache<Element>(this, CACHE_KEY_MASK, () => {\n\t\t\tconst mask = document.createElement(tagName);\n\t\t\tmask.className = className;\n\t\t\tmask.style.overflow = 'hidden';\n\t\t\tmask.style.height = '100%';\n\t\t\telement.parentNode?.insertBefore(mask, element);\n\t\t\tmask.appendChild(element);\n\t\t\treturn mask;\n\t\t});\n\n\t\tconst cachedHeight = fromCache<number>(this, CACHE_KEY_HEIGHT);\n\t\tif (height === cachedHeight) {\n\t\t\treturn;\n\t\t}\n\n\t\twriteCache(this, CACHE_KEY_HEIGHT, height);\n\n\t\telement.style.height = `calc(100% + ${height}px)`;\n\t\telement.style.marginBottom = `${height * -1}px`;\n\t}\n\n\t/**\n\t * Removes the mask element and unwraps the carousel element.\n\t * @internal\n\t */\n\tprivate _remove(): void {\n\t\tconst { el } = fromCache<IProxy>(this, CACHE_KEY_PROXY) as IProxy;\n\t\tconst mask = fromCache<HTMLDivElement>(this, CACHE_KEY_MASK);\n\n\t\tmask?.parentNode?.insertBefore(el, mask);\n\t\tmask?.parentNode?.removeChild(mask);\n\t\tel.removeAttribute('style');\n\t}\n\n}\n","/**\n * The representation of all visual items in a carousel. The is at least one\n * item that is always visible. In cases (e.g. display: none) where visibility\n * is uncalculatable this is `[0]`.\n *\n * Each index represents the index of the child elements ({@link Carousel.items | see items})\n * inside the dom. The index of these elements inside the dom may not be\n * equivalent to the visual indexes (e.g. css flexbox-ordering or css grids).\n */\nexport type Index = [number, ...number[]];\n\n\n/**\n * The representation of item indexes grouped into pages. These pages are the\n * available entry points for control features like buttons and pagination.\n *\n * The indexes inside each grouped page is based on the visual order of the\n * child elements ({@link Carousel.items | see items}).\n *\n * For example:\n * ```\n *   <div class=\"carousel\">\n *     <div class=\"item\" style=\"width: 100%; order: 3\">Item 1</div>\n *     <div class=\"item\" style=\"width: 50%; order: 2\">Item 2</div>\n *     <div class=\"item\" style=\"width: 50%; order: 1\">Item 3</div>\n *   </div>\n * ```\n *\n * The pages representation would look like: `[[2], [1, 0]]` (see ordering and width)\n */\nexport type Pages = [Index, ...Index[]];\n\n\n/**\n * The minimal represenation of the carousel control properties.\n * @internal\n */\ninterface ICore {\n\tget id(): string;\n\tget el(): Element;\n\tget mask(): Element | null;\n\tget index(): Index;\n\tset index(value: Index);\n\tget items(): HTMLElement[];\n\tget pages(): Pages;\n\tget pageIndex(): number;\n}\n\n\n/**\n * The carousel interface.\n */\nexport interface ICarousel extends ICore {\n\tbehavior: ScrollBehavior;\n\tdestroy(): void;\n\tupdate(): void;\n}\n\n\n/**\n * The feature proxy interface.\n */\nexport interface IProxy extends ICore {\n\tupdate(sender: IFeature): void;\n}\n\n\n/**\n * The feature interface.\n */\nexport interface IFeature {\n\n\t/**\n\t * Each feature needs to return a constant name that identifies the plugin.\n\t * Build in features are using the prefix `buildin:`.\n\t */\n\tget name(): string;\n\n\t/**\n\t * Initializes this feature. This function will be called by the carousel\n\t * instance and should not be called manually.\n\t * @param proxy the proxy instance between carousel and feature\n\t */\n\tinit(proxy: IProxy): void;\n\n\t/**\n\t * Destroys this feature. This function will be called by the carousel instance\n\t * and should not be called manually.\n\t */\n\tdestroy(): void;\n\n\t/**\n\t * This triggers the feature to update its inner state. This function will be\n\t * called by the carousel instance and should not be called manually. The\n\t * carousel passes a data object that includes the update reason. This can be\n\t * used to selectively/partially update sections of the feature.\n\t * @param data dataset that triggered the update\n\t * @param data.reason is the update reason (why this was triggered)\n\t */\n\tupdate(data :UpdateEvent): void;\n}\n\n\n/**\n * The event that is passed into each feature.\n */\nexport type UpdateEvent = {\n\n\t/**\n\t * The reason why this update was triggered.\n\t */\n\ttype: UpdateType;\n\n};\n\n\n/**\n * Possible types of an update.\n */\nexport enum UpdateType {\n\tSCROLL = 'scroll',\n\tRESIZE = 'resize',\n\tFORCED = 'forced',\n\tFEATURE = 'feature',\n}\n\n\n/**\n * The browsers scroll behavior.\n * See {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollTo | scrollTo on MDN}\n */\nexport enum ScrollBehavior {\n\tAUTO = 'auto',\n\tSMOOTH = 'smooth',\n}\n\n\n/**\n * A function that can be used as callback on scroll events.\n */\nexport type ScrollHook = <T>(event: {\n\tindex: Index;\n\ttype: 'scroll';\n\ttarget: T;\n\toriginalEvent: Event;\n}) => void;\n\n\n/**\n * A filter function to filter specific child elements ({@link Carousel.items | see items})\n * of the carousel.\n */\nexport type FilterItemFn =\n\t((item: HTMLElement) => boolean) |\n\t((item: HTMLElement, index: number) => boolean) |\n\t((item: HTMLElement, index: number, array: HTMLElement[]) => boolean);\n","exports.interopDefault = function (a) {\n  return a && a.__esModule ? a : {default: a};\n};\n\nexports.defineInteropFlag = function (a) {\n  Object.defineProperty(a, '__esModule', {value: true});\n};\n\nexports.exportAll = function (source, dest) {\n  Object.keys(source).forEach(function (key) {\n    if (\n      key === 'default' ||\n      key === '__esModule' ||\n      Object.prototype.hasOwnProperty.call(dest, key)\n    ) {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function () {\n        return source[key];\n      },\n    });\n  });\n\n  return dest;\n};\n\nexports.export = function (dest, destName, get) {\n  Object.defineProperty(dest, destName, {\n    enumerable: true,\n    get: get,\n  });\n};\n","// The key of a WeakMap must be an object. There is no other type that matches\n// or is valid for @typescript-eslint.\n// eslint-disable-next-line @typescript-eslint/ban-types\ntype Reference = object;\n\ntype Storage = Map<string, unknown>;\n\nconst __CACHE = new WeakMap<Reference, Storage>();\n\n/**\n * Returns the cache entry by a specific key of a given reference. If the cache\n * is not filled and the key doesn't exisit this will retrun undefined.\n * @typeParam T is the type of the cached value\n * @param ref the reference\n * @param key the storage key\n * @returns the cached value or undefined\n */\nexport function fromCache<T = unknown>(ref: Reference, key: string): T | undefined;\n\n/**\n * Returns the cache entry by a specific key of a given reference. If the cache\n * is not filled and the key doesn't exisit, the factory function is called to\n * generate a value. This value will be cached and returned.\n * @typeParam T is the type of the cached value\n * @param ref the reference\n * @param key the storage key\n * @param factory the factory function\n * @returns the cached value\n */\nexport function fromCache<T = unknown>(ref: Reference, key: string, factory: () => T): T;\n\nexport function fromCache<T = unknown>(ref: Reference, key: string, factory?: () => T): T | undefined {\n\tconst storage = __CACHE.get(ref) || new Map<string, T>();\n\tif (storage.has(key)) {\n\t\treturn storage.get(key) as T;\n\t}\n\n\tif (!factory) {\n\t\treturn undefined;\n\t}\n\n\tconst value = factory();\n\tstorage.set(key, value);\n\t__CACHE.set(ref, storage);\n\treturn value;\n}\n\n/**\n * Explicitly writes a value into the cache.\n * @typeParam T is the type of the value to cache\n * @param ref the reference\n * @param key the storage key\n * @param value the value\n */\nexport function writeCache<T = unknown>(ref: Reference, key: string, value: T): void {\n\tconst storage = __CACHE.get(ref) || new Map<string, T>();\n\tstorage.set(key, value);\n\t__CACHE.set(ref, storage);\n}\n\n/**\n * Creates the cache entry by as specific key of a given reference.\n * @param ref the reference\n * @param key the storage key\n */\nexport function clearCache(ref: Reference, key: string): void {\n\tconst storage = __CACHE.get(ref);\n\tif (!storage || !storage.has(key)) {\n\t\treturn;\n\t}\n\n\tstorage.delete(key);\n}\n\n/**\n * Clears the full cache by a given reference.\n * @param ref the reference.\n */\nexport function clearFullCache(ref: Reference): void {\n\t__CACHE.delete(ref);\n}\n\n/**\n * This exposes the cache instance for test environments. Otherwise it will be null.\n * @internal\n */\n/* This should not be part of the coverage report: test util */\n/* istanbul ignore next */\nexport const cacheInstance = (process.env.NODE_ENV === 'test') ? __CACHE : null;\n","import { clearCache, fromCache } from '../../utils/cache';\n\n/**\n * Dataset of scrollbar dimensions\n * @internal\n */\nexport type ScrollbarDimensions = {\n\n\t/**\n\t * Vertical size of a scrollbar.\n\t */\n\theight: number,\n};\n\n\nconst CACHE_KEY_DIMENSIONS = 'dims';\n\n\n/**\n * Helper class for scrollbar features.\n * @internal\n */\nexport class Scrollbar {\n\n\t/**\n\t * Creates an instance.\n\t * @internal\n\t */\n\tconstructor() {\n\t\twindow.addEventListener('resize', () => {\n\t\t\tclearCache(this, CACHE_KEY_DIMENSIONS);\n\t\t});\n\t}\n\n\t/**\n\t * Calculates the dimensions of a scrollbar in the current browser. The result\n\t * of the computation will be cached for this instance.\n\t *\n\t * Inspired by https://gist.github.com/kflorence/3086552\n\t *\n\t * @return the dimensions of the scrollar\n\t */\n\tget dimensions(): ScrollbarDimensions {\n\t\treturn fromCache<ScrollbarDimensions>(this, CACHE_KEY_DIMENSIONS, () => {\n\t\t\tconst inner = document.createElement('div');\n\t\t\tconst outer = document.createElement('div');\n\n\t\t\tdocument.body.appendChild(outer);\n\t\t\touter.style.position = 'absolute';\n\t\t\touter.style.top = '0px';\n\t\t\touter.style.left = '0px';\n\t\t\touter.style.visibility = 'hidden';\n\t\t\touter.appendChild(inner);\n\n\t\t\t// Disabled, not needed for current feature set.\n\t\t\t//\n\t\t\t// Calculate width:\n\t\t\t// inner.style.width = '100%';\n\t\t\t// inner.style.height = '200px';\n\t\t\t// outer.style.width = '200px';\n\t\t\t// outer.style.height = '150px';\n\t\t\t// outer.style.overflow = 'hidden';\n\t\t\t// w1 = inner.offsetWidth;\n\t\t\t// outer.style.overflow = 'scroll';\n\t\t\t// w2 = inner.offsetWidth;\n\t\t\t// w2 = (w1 === w2) ? outer.clientWidth : w2;\n\t\t\t// width = w1 - w2;\n\n\t\t\t// Calculate height:\n\t\t\tinner.style.width = '200px';\n\t\t\tinner.style.height = '100%';\n\t\t\touter.style.width = '150px';\n\t\t\touter.style.height = '200px';\n\t\t\touter.style.overflow = 'hidden';\n\n\t\t\tconst h1 = inner.offsetHeight;\n\t\t\touter.style.overflow = 'scroll';\n\t\t\tlet h2 = inner.offsetHeight;\n\t\t\th2 = (h1 === h2) ? outer.clientHeight : h2;\n\t\t\tconst height = h1 - h2;\n\n\t\t\tdocument.body.removeChild(outer);\n\n\t\t\treturn {\n\t\t\t\t// width,\n\t\t\t\theight,\n\t\t\t};\n\t\t});\n\t}\n\n}\n","import { ICarousel, IFeature, Index, IProxy, Pages, UpdateType } from \"./types\";\nimport { fromCache, writeCache } from './utils/cache';\n\n\nconst CACHE_KEY_INSTANCE = 'inst';\nconst CACHE_KEY_FEATURES = 'feat';\n\n\n/**\n * Helper to access the instance cache.\n * @internal\n */\nfunction __getInstance(ref: Proxy): ICarousel {\n\treturn fromCache<ICarousel>(ref, CACHE_KEY_INSTANCE) as ICarousel;\n}\n\n\n/**\n * Helper to access the features cache.\n * @internal\n */\nfunction __getFeatures(ref: Proxy): IFeature[] {\n\treturn fromCache<IFeature[]>(ref, CACHE_KEY_FEATURES) as IFeature[];\n}\n\n/**\n * A proxy instance between carousel and a feature. Restricts the access for\n * features to the carousel instance.\n */\nexport class Proxy implements IProxy {\n\n\t/**\n\t * Creates an instance of the proxy.\n\t * @param instance the carousel instance to proxy the access to.\n\t * @param features all the features that should access the carousel through this instance.\n\t */\n\tconstructor(instance: ICarousel, features: IFeature[]) {\n\t\twriteCache(this, CACHE_KEY_INSTANCE, instance);\n\t\twriteCache(this, CACHE_KEY_FEATURES, features);\n\t}\n\n\t/**\n\t * Proxies the {@link Carousel.id | `id`} getter of the carousel.\n\t */\n\tpublic get id(): string {\n\t\treturn __getInstance(this).id;\n\t}\n\n\t/**\n\t * Proxies the {@link Carousel.el | `el`} getter of the carousel.\n\t */\n\tpublic get el(): Element {\n\t\treturn __getInstance(this).el;\n\t}\n\n\t/**\n\t * Proxies the {@link Carousel.mask | `mask`} getter of the carousel.\n\t */\n\tpublic get mask(): Element | null {\n\t\treturn __getInstance(this).mask;\n\t}\n\n\t/**\n\t * Proxies the {@link Carousel.index | `index`} getter of the carousel.\n\t */\n\tpublic get index(): Index {\n\t\treturn __getInstance(this).index;\n\t}\n\n\t/**\n\t * Proxies the {@link Carousel.index | `index`} setter of the carousel.\n\t */\n\tpublic set index(value: Index) {\n\t\t__getInstance(this).index = value;\n\t}\n\n\t/**\n\t * Proxies the {@link Carousel.items | `items`} getter of the carousel.\n\t */\n\tpublic get items(): HTMLElement[] {\n\t\treturn __getInstance(this).items;\n\t}\n\n\t/**\n\t * Proxies the {@link Carousel.pages | `pages`} getter of the carousel.\n\t */\n\tpublic get pages(): Pages {\n\t\treturn __getInstance(this).pages;\n\t}\n\n\t/**\n\t * Proxies the {@link Carousel.pagesIndex | `pagesIndex`} getter of the carousel.\n\t */\n\tpublic get pageIndex(): number {\n\t\treturn __getInstance(this).pageIndex;\n\t}\n\n\t/**\n\t * Function to trigger an update from a feature. This will send an update to\n\t * the carousel instance and all other attached features exept the sender.\n\t * @param sender feature that triggers the update.\n\t */\n\tpublic update(sender: IFeature): void {\n\t\t__getInstance(this).update();\n\n\t\t// Trigger update in all other features except the source feature that\n\t\t// triggered the event:\n\t\t__getFeatures(this).forEach((feature): void => {\n\t\t\tif (feature === sender) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfeature.update({ type: UpdateType.FEATURE });\n\t\t});\n\t}\n\n}\n","// See: https://codeburst.io/throttling-and-debouncing-in-javascript-b01cad5c8edf\n\n\n/**\n * Generic function\n */\nexport type Source = (...args: never[]) => unknown;\n\n\n/**\n * Debounced function\n * @typeParam F is the shape of the original function.\n */\nexport type Debounced<F extends Source> = (...args: Parameters<F>) => void;\n\n\n/**\n * Creates a debounced version for a given function in a given delay (in ms).\n * @typeParam F is the shape of the function to debounce.\n * @param func the original function\n * @param delay the delay in milliseconds (ms)\n * @returns the debounced function\n */\nexport function debounce<F extends Source>(func: F, delay: number): Debounced<F> {\n\tlet timeout: ReturnType<typeof setTimeout> | null = null;\n\tconst debounced = (...args: Parameters<F>) => {\n\t\tif (timeout !== null) {\n\t\t\tclearTimeout(timeout);\n\t\t}\n\n\t\ttimeout = setTimeout(() => func(...args), delay);\n\t};\n\n\treturn debounced;\n}\n","import { IFeature, IProxy } from '../../types';\nimport { clearFullCache, fromCache, writeCache } from '../../utils/cache';\nimport { render } from '../../utils/render';\n\n\nconst FEATURE_NAME = 'buildin:buttons';\n\nconst CACHE_KEY_PROXY = 'prxy';\nconst CACHE_KEY_CONFIGURATION = 'conf';\nconst CACHE_KEY_BUTTONS = 'btns';\n\nconst EVENT_CLICK = 'click';\n\n\n/**\n * The template function to render a HTML markup of a button.\n * @param context the template context containing the required data to render\n * @return the HTML markup\n */\nexport type Template = (context: Context) => string;\n\n\n/**\n * The template rendering context.\n */\nexport type Context = {\n\tcontrols: string;\n\tclassName: string;\n\tlabel: string;\n\ttitle: string;\n};\n\n\n/**\n * Short type of HTMLButtonElement or nullish (not rendered).\n * @interal\n */\ntype Button = HTMLButtonElement | null;\n\n\n/**\n * The options for the buttons feature.\n */\nexport type Options = {\n\t/**\n\t * Render function for a single button.\n\t */\n\ttemplate?: Template;\n\n\t/**\n\t * The shared class name for both buttons (next and previous).\n\t * @defaultValue `'button'`\n\t */\n\tclassName?: string;\n\n\t/**\n\t * The class name of the next button.\n\t * @defaultValue `'is-next'`\n\t */\n\tnextClassName?: string;\n\n\t/**\n\t * The text label of the next button.\n\t * @defaultValue `'Next'`\n\t */\n\tnextLabel?: string;\n\n\t/**\n\t * The title attribute value of the next button.\n\t * @defaultValue `'Go to next'`\n\t */\n\tnextTitle?: string;\n\n\t/**\n\t * The class name of the previous button.\n\t * @defaultValue `'is-previous'`\n\t */\n\tpreviousClassName?: string;\n\n\t/**\n\t * The text label of the previous button.\n\t * @defaultValue `'Previous'`\n\t */\n\tpreviousLabel?: string;\n\n\t/**\n\t * The title attribute value of the previous button.\n\t * @defaultValue `'Go to previous'`\n\t */\n\tpreviousTitle?: string;\n\n};\n\n\n/**\n * The required configuration for buttons feature.\n * @internal\n */\ntype Configuration = Required<Options>;\n\n\nconst DEFAULTS: Configuration = {\n\ttemplate: ({ className, controls, label, title }: Context) => `\n\t\t<button type=\"button\" class=\"${className}\" aria-label=\"${label}\" title=\"${title}\" aria-controls=\"${controls}\">\n\t\t\t<span>${label}</span>\n\t\t</button>\n\t`,\n\tclassName: 'button',\n\n\tnextClassName: 'is-next',\n\tnextLabel: 'Next',\n\tnextTitle: 'Go to next',\n\n\tpreviousClassName: 'is-previous',\n\tpreviousLabel: 'Previous',\n\tpreviousTitle: 'Go to previous',\n};\n\n\n/**\n * The feature to enable button controls (next and previous) for a carousel.\n */\nexport class Buttons implements IFeature {\n\n\t/**\n\t * Creates an instance of this feature.\n\t * @param options are the options to configure this instance\n\t */\n\tconstructor(options: Options = {}) {\n\t\twriteCache(this, CACHE_KEY_CONFIGURATION, { ...DEFAULTS, ...options });\n\t\tthis._onPrev = this._onPrev.bind(this);\n\t\tthis._onNext = this._onNext.bind(this);\n\t}\n\n\t/**\n\t * Returns the name of this feature.\n\t */\n\tpublic get name(): typeof FEATURE_NAME {\n\t\treturn FEATURE_NAME;\n\t}\n\n\t/**\n\t * Initializes this feature. This function will be called by the carousel\n\t * instance and should not be called manually.\n\t * @internal\n\t * @param proxy the proxy instance between carousel and feature\n\t */\n\tpublic init(proxy: IProxy): void {\n\t\twriteCache(this, CACHE_KEY_PROXY, proxy);\n\t\tthis._render();\n\t}\n\n\t/**\n\t * Destroys this feature. This function will be called by the carousel instance\n\t * and should not be called manually.\n\t * @internal\n\t */\n\tpublic destroy(): void {\n\t\tthis._remove();\n\t\tclearFullCache(this);\n\t}\n\n\t/**\n\t * This triggers the feature to update its inner state. This function will be\n\t * called by the carousel instance and should not be called manually. The\n\t * carousel passes a event object that includes the update reason. This can be\n\t * used to selectively/partially update sections of the feature.\n\t * @internal\n\t */\n\tpublic update(/* event :UpdateEvent */): void {\n\t\tthis._render();\n\t}\n\n\t/**\n\t * Renders and update the button elements. Buttons will only be rendered once\n\t * and then loaded from cache. When calling this function twice or more, the\n\t * button states will be updated based on the scroll position.\n\t * @internal\n\t */\n\tprivate _render(): void {\n\t\tconst proxy = fromCache<IProxy>(this, CACHE_KEY_PROXY) as IProxy;\n\t\tconst config = fromCache<Configuration>(this, CACHE_KEY_CONFIGURATION) as Configuration;\n\n\t\tconst { el, mask, pages, pageIndex } = proxy;\n\n\t\t// Render buttons only once. Load them from cache if already rendered and\n\t\t// attached to the dom:\n\t\tconst [next, previous] = fromCache<Button[]>(\n\t\t\tthis, CACHE_KEY_BUTTONS, () => {\n\t\t\t\tconst target = mask ?? el;\n\t\t\t\tconst {\n\t\t\t\t\ttemplate, className,\n\t\t\t\t\tpreviousClassName, previousLabel, previousTitle,\n\t\t\t\t\tnextClassName, nextLabel, nextTitle,\n\t\t\t\t} = config;\n\n\t\t\t\t// Create button elements:\n\t\t\t\tconst settings = [\n\t\t\t\t\t{\n\t\t\t\t\t\tcontrols: el.id,\n\t\t\t\t\t\tlabel: nextLabel,\n\t\t\t\t\t\ttitle: nextTitle,\n\t\t\t\t\t\tclassName: [className, nextClassName].join(' '),\n\t\t\t\t\t\t// The onClick listener is already bound in the constructor.\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/unbound-method\n\t\t\t\t\t\thandler: this._onNext,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tcontrols: el.id,\n\t\t\t\t\t\tlabel: previousLabel,\n\t\t\t\t\t\ttitle: previousTitle,\n\t\t\t\t\t\tclassName: [className, previousClassName].join(' '),\n\t\t\t\t\t\t// The onClick listener is already bound in the constructor.\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/unbound-method\n\t\t\t\t\t\thandler: this._onPrev,\n\t\t\t\t\t},\n\t\t\t\t];\n\n\t\t\t\treturn settings.map(({ handler, ...params }) => {\n\t\t\t\t\tconst button = render<HTMLButtonElement, Context>(template, params);\n\t\t\t\t\tif (!button) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\tbutton.addEventListener(EVENT_CLICK, handler);\n\t\t\t\t\ttarget.parentNode?.insertBefore(button, target.nextSibling);\n\t\t\t\t\treturn button;\n\t\t\t\t});\n\t\t\t},\n\t\t);\n\n\t\tif (next) {\n\t\t\tconst lastPage = pages[pageIndex + 1];\n\t\t\tconst isLastPage = lastPage === undefined;\n\t\t\tnext.disabled = isLastPage;\n\t\t}\n\n\t\tif (previous) {\n\t\t\tconst firstPage = pages[pageIndex - 1];\n\t\t\tconst isFirstPage = firstPage === undefined;\n\t\t\tprevious.disabled = isFirstPage;\n\t\t}\n\t}\n\n\t/**\n\t * Removes all buttons from the dom and detaches all event handler.\n\t * @internal\n\t */\n\tprivate _remove(): void {\n\t\tconst buttons = fromCache<Button[]>(this, CACHE_KEY_BUTTONS);\n\n\t\tbuttons?.forEach((button): void => {\n\t\t\t// The onClick listener is already bound in the constructor.\n\t\t\t//\n\t\t\t// eslint-disable-next-line @typescript-eslint/unbound-method\n\t\t\tbutton?.removeEventListener(EVENT_CLICK, this._onPrev);\n\t\t\t// The onClick listener is already bound in the constructor.\n\t\t\t//\n\t\t\t// eslint-disable-next-line @typescript-eslint/unbound-method\n\t\t\tbutton?.removeEventListener(EVENT_CLICK, this._onNext);\n\t\t\tbutton?.parentNode?.removeChild(button);\n\t\t});\n\t}\n\n\t/**\n\t * Event handler to navigate backwards (to the left).\n\t * @internal\n\t */\n\tprivate _onPrev(): void {\n\t\tconst proxy = fromCache<IProxy>(this, CACHE_KEY_PROXY) as IProxy;\n\t\tconst { pages, pageIndex } = proxy;\n\t\tconst index = pages[pageIndex - 1] || pages[0];\n\t\tproxy.index = index;\n\t}\n\n\t/**\n\t * Event handler to navigate forwards (to the right).\n\t * @internal\n\t */\n\tprivate _onNext(): void {\n\t\tconst proxy = fromCache<IProxy>(this, CACHE_KEY_PROXY) as IProxy;\n\t\tconst { pages, pageIndex } = proxy;\n\t\tconst index = pages[pageIndex + 1] || pages[pages.length - 1];\n\t\tproxy.index = index;\n\t}\n\n}\n","/**\n * Renders a template (function) to into an HTML element. The template needs to\n * return a valid HTML string (with a single root element). A context with\n * key/value pairs will be passed into the template to allow dynamic rendering.\n * @typeParam El is the type of the rendered dom element.\n * @typeParam Context is the shape of the context data object\n * @param template a function to render a template\n * @param context context data for the template\n * @returns the rendered htmml element\n */\nexport function render<El = HTMLElement, Context = Record<string, unknown>>(\n\ttemplate: (context: Context) => string,\n\tcontext: Context,\n): El | null {\n\tconst el = document.createElement('div');\n\tel.innerHTML = template(context);\n\n\tconst ref = el.firstElementChild;\n\tif (!ref) {\n\t\treturn null;\n\t}\n\n\treturn ref as unknown as El;\n}\n","import { IFeature, IProxy } from '../../types';\nimport { clearCache, clearFullCache, fromCache, writeCache } from '../../utils/cache';\n\n\nconst FEATURE_NAME = 'buildin:mouse';\n\nconst CACHE_KEY_PROXY = 'prxy';\nconst CACHE_KEY_CONFIGURATION = 'conf';\nconst CACHE_KEY_PAGE_INDEX = 'pgidx';\nconst CACHE_KEY_POSITION_X = 'posx';\nconst CACHE_KEY_SCROLL_LEFT = 'scrl';\nconst CACHE_KEY_TIMEOUT = 'time';\n\nconst CURSOR_GRAB = 'grab';\nconst CURSOR_GRABBING = 'grabbing';\n\nconst EVENT_START = 'mousedown';\nconst EVENT_DRAG = 'mousemove';\nconst EVENT_END = 'mouseup';\n\nconst THRESHOLD_MIN = 100;\nconst THRESHOLD_MAX = 250;\nconst THRESHOLD_FACTOR = 0.25; // Relative carousel element width\n\n\n// We are ignoring this due to this whole feature is only here to make TS happy.\n/* istanbul ignore next */\n/**\n * Extracts the client x position from an event depending on the event type.\n * @internal\n * @param event the event\n * @returns the client x position\n */\nfunction __getPositionX(event: Event): number {\n\tif (event instanceof MouseEvent) {\n\t\treturn event.clientX;\n\t}\n\n\treturn 0;\n}\n\n\n/**\n * The options for the pagination feature.\n */\nexport type Options = {\n\n\t/**\n\t * Show a drag indicator using css cursor properties (grab and grabbing).\n\t */\n\tindicator?: boolean;\n\n\t/**\n\t * A hook function that is called when the user stats to drag.\n\t */\n\tonStart?: ((event: HookEvent) => void);\n\n\t/**\n\t * A hook function that is called when the user is dragging.\n\t */\n\tonDrag?: ((event: HookEvent) => void);\n\n\t/**\n\t * A hook function that is called when the user stops to drag.\n\t */\n\tonEnd?: ((event: HookEvent) => void);\n\n};\n\n/**\n * The event object that is passed for each hook.\n */\nexport type HookEvent = {\n\toriginalEvent: Event,\n};\n\n/**\n * The keys in the options that are hooks.\n * @internal\n */\ntype Hooks = 'onStart' | 'onDrag' | 'onEnd';\n\n\n/**\n * The required configuration for pagination feature.\n * @internal\n */\ntype Configuration =\n\tOmit<Required<Options>, Hooks> &\n\tOmit<Options, Exclude<keyof Options, Hooks>>;\n\n\nconst DEFAULTS: Configuration = {\n\tindicator: false,\n};\n\n\n/**\n * Feature to enable mouse controls\n */\nexport class Mouse implements IFeature {\n\n\t/**\n\t * Creates an instance of this feature.\n\t * @param options are the options to configure this instance\n\t */\n\tconstructor(options: Options = {}) {\n\t\twriteCache(this, CACHE_KEY_CONFIGURATION, { ...DEFAULTS, ...options });\n\t\tthis._onStart = this._onStart.bind(this);\n\t\tthis._onDrag = this._onDrag.bind(this);\n\t\tthis._onEnd = this._onEnd.bind(this);\n\t}\n\n\t/**\n\t * Returns the name of this feature.\n\t */\n\tget name(): typeof FEATURE_NAME {\n\t\treturn FEATURE_NAME;\n\t}\n\n\t/**\n\t * Initializes this feature. This function will be called by the carousel\n\t * instance and should not be called manually.\n\t * @internal\n\t * @param proxy the proxy instance between carousel and feature\n\t */\n\tpublic init(proxy: IProxy): void {\n\t\twriteCache(this, CACHE_KEY_PROXY, proxy);\n\n\t\tconst config = fromCache<Configuration>(this, CACHE_KEY_CONFIGURATION) as Configuration;\n\t\tconst { el } = proxy;\n\t\tconst element = el as HTMLElement;\n\t\telement.style.cursor = config.indicator ? CURSOR_GRAB : '';\n\n\t\t// The handler is already bound in the constructor.\n\t\t//\n\t\t// eslint-disable-next-line @typescript-eslint/unbound-method\n\t\tel.addEventListener(EVENT_START, this._onStart, { passive: true });\n\t}\n\n\t/**\n\t * Destroys this feature. This function will be called by the carousel instance\n\t * and should not be called manually.\n\t * @internal\n\t */\n\tpublic destroy(): void {\n\t\tclearFullCache(this);\n\t}\n\n\t/**\n\t * This triggers the feature to update its inner state. This function will be\n\t * called by the carousel instance and should not be called manually. The\n\t * carousel passes a event object that includes the update reason. This can be\n\t * used to selectively/partially update sections of the feature.\n\t * @internal\n\t */\n\tpublic update(): void {\n\t\t/* nothing to update yet */\n\t}\n\n\t/**\n\t * Handles the drag start event.\n\t * @internal\n\t * @param event the event that triggered the drag start\n\t */\n\tprivate _onStart(event: Event): void {\n\t\tconst timeout = fromCache<number>(this, CACHE_KEY_TIMEOUT);\n\t\tclearTimeout(timeout);\n\n\t\tconst config = fromCache<Configuration>(this, CACHE_KEY_CONFIGURATION) as Configuration;\n\t\tconst proxy = fromCache<IProxy>(this, CACHE_KEY_PROXY) as IProxy;\n\t\tconst element = proxy.el as HTMLElement;\n\t\tfromCache(this, CACHE_KEY_SCROLL_LEFT, (): number => element.scrollLeft);\n\t\tfromCache(this, CACHE_KEY_POSITION_X, (): number => __getPositionX(event));\n\t\tfromCache(this, CACHE_KEY_PAGE_INDEX, (): number => proxy.pageIndex);\n\n\t\t// Reset scroll behavior and scroll snapping to emulate regular scrolling.\n\t\t// Prevent user selection while the user drags:\n\t\telement.style.userSelect = 'none';\n\t\telement.style.scrollBehavior = 'auto';\n\t\telement.style.scrollSnapType = 'none';\n\t\telement.style.cursor = config.indicator ? CURSOR_GRABBING : '';\n\n\t\t// The handlers are already bound in the constructor.\n\t\t//\n\t\t/* eslint-disable @typescript-eslint/unbound-method */\n\t\twindow.addEventListener(EVENT_DRAG, this._onDrag, { passive: true });\n\t\twindow.addEventListener(EVENT_END, this._onEnd, { passive: true });\n\t\t/* eslint-enable @typescript-eslint/unbound-method */\n\n\t\t// Call the hook:\n\t\tconfig.onStart?.({ originalEvent: event });\n\t}\n\n\t/**\n\t * Handles the drag event. Calculates and updates scroll position.\n\t * @internal\n\t * @param event the event that triggered the dragging\n\t */\n\tprivate _onDrag(event: Event): void {\n\t\tconst config = fromCache<Configuration>(this, CACHE_KEY_CONFIGURATION) as Configuration;\n\t\tconst { el } = fromCache<IProxy>(this, CACHE_KEY_PROXY) as IProxy;\n\t\tconst left = fromCache<number>(this, CACHE_KEY_SCROLL_LEFT) ?? 0;\n\t\tconst x = fromCache<number>(this, CACHE_KEY_POSITION_X) ?? 0;\n\t\tconst currentX = __getPositionX(event);\n\t\tconst deltaX = x - currentX;\n\n\t\tel.scrollLeft = left + deltaX;\n\n\t\t// Call the hook:\n\t\tconfig.onDrag?.({ originalEvent: event });\n\t}\n\n\t/**\n\t * Handles the drag end event.\n\t * @internal\n\t * @param event the event that triggered the drag end\n\t */\n\tprivate _onEnd(event: Event): void {\n\t\tconst proxy = fromCache<IProxy>(this, CACHE_KEY_PROXY) as IProxy;\n\t\tconst config = fromCache<Configuration>(this, CACHE_KEY_CONFIGURATION) as Configuration;\n\t\tconst left = fromCache<number>(this, CACHE_KEY_SCROLL_LEFT) ?? 0;\n\t\tconst pageIndex = fromCache<number>(this, CACHE_KEY_PAGE_INDEX) ?? 0;\n\t\tclearCache(this, CACHE_KEY_SCROLL_LEFT);\n\t\tclearCache(this, CACHE_KEY_POSITION_X);\n\t\tclearCache(this, CACHE_KEY_PAGE_INDEX);\n\n\t\tconst element = proxy.el as HTMLElement;\n\t\tconst threshold = Math.min(Math.max(THRESHOLD_MIN, element.clientWidth * THRESHOLD_FACTOR), THRESHOLD_MAX);\n\t\tconst currentLeft = element.scrollLeft;\n\t\tconst distance = currentLeft - left;\n\t\tconst offset = Math.abs(distance);\n\n\t\telement.style.removeProperty('user-select');\n\t\telement.style.removeProperty('scroll-behavior');\n\t\telement.style.cursor = config.indicator ? CURSOR_GRAB : '';\n\n\t\t// Apply the index. If the scroll offset is higher that the threshold,\n\t\t// navigate to the next page depending on the drag direction.\n\t\tlet index = proxy.index;\n\t\tif (offset > threshold) {\n\t\t\tconst direction = distance / offset;\n\t\t\tconst at = Math.max(pageIndex + direction, 0);\n\t\t\tindex = proxy.pages[at] ?? index;\n\t\t}\n\n\t\t// Apply the index until the styles are rendered to the element. This is\n\t\t// required to have a smooth scroll-behaviour which is disabled during the\n\t\t// mouse dragging.\n\t\twindow.requestAnimationFrame(() => {\n\t\t\tproxy.index = index;\n\t\t});\n\n\t\t// Get around the scroll-snapping. Enable it until the position is already\n\t\t// applied. This will take ~1000ms depending on distance and browser\n\t\t// behaviour.\n\t\tconst timeout = window.setTimeout(() => {\n\t\t\telement.style.removeProperty('scroll-snap-type');\n\t\t}, 1000);\n\n\t\twriteCache(this, CACHE_KEY_TIMEOUT, timeout);\n\n\t\t// The handlers are already bound in the constructor.\n\t\t//\n\t\t/* eslint-disable @typescript-eslint/unbound-method */\n\t\twindow.removeEventListener(EVENT_DRAG, this._onDrag);\n\t\twindow.removeEventListener(EVENT_END, this._onEnd);\n\t\t/* eslint-enable @typescript-eslint/unbound-method */\n\n\t\t// Call the hook:\n\t\tconfig.onEnd?.({ originalEvent: event });\n\t}\n\n}\n","import { IFeature, IProxy, UpdateEvent, UpdateType } from '../../types';\nimport { clearCache, clearFullCache, fromCache, writeCache } from '../../utils/cache';\nimport { render } from '../../utils/render';\n\n\nconst FEATURE_NAME = 'buildin:pagination';\n\nconst CACHE_KEY_PROXY = 'prxy';\nconst CACHE_KEY_CONFIGURATION = 'conf';\nconst CACHE_KEY_PAGINATION = 'pags';\nconst CACHE_KEY_BUTTONS = 'btns';\n\n\n/**\n * The template function to render a HTML markup of a pagination.\n * @param context the template context containing the required data to render\n * @return the HTML markup\n */\nexport type Template = (params: Context) => string;\n\n\n/**\n * The template rendering context.\n */\nexport type Context = {\n\tcontrols: string;\n\tclassName: string;\n\tlabel: TextTemplate;\n\ttitle: TextTemplate;\n\tpages: number[][];\n};\n\n\n/**\n * A text template function to render a text node. This will be used for button\n * labels and text-attributes inside the pagination\n */\nexport type TextTemplate = (params: TextContext) => string;\n\n\n/**\n * The text template rendering context.\n */\nexport type TextContext = {\n\tindex: number;\n\tpage: number[];\n\tpages: number[][];\n};\n\n\n/**\n * The options for the pagination feature.\n */\nexport type Options = {\n\n\t/**\n\t * Render function for the pagination elemements.\n\t */\n\ttemplate?: Template;\n\n\t/**\n\t * The class name the pagination element.\n\t * @defaultValue `'pagination'`\n\t */\n\tclassName?: string;\n\n\t/**\n\t * Render function for each button label inside the pagination.\n\t */\n\tlabel?: TextTemplate;\n\n\t/**\n\t * Render function for each button title attribute inside the pagination.\n\t */\n\ttitle?: TextTemplate;\n\n};\n\n\n/**\n * The required configuration for pagination feature.\n * @internal\n */\ntype Configuration = Required<Options>;\n\nconst DEFAULTS: Configuration = {\n\t// @TODO: ESLint don't like the nested template literals and loops.\n\t/* eslint-disable indent */\n\ttemplate: ({ className, controls, pages, label, title }: Context) => `\n\t\t<ul class=\"${className}\">\n\t\t\t${pages.map((page, index) => {\n\t\t\t\tconst data = { index, page, pages };\n\t\t\t\tconst labelStr = label(data);\n\t\t\t\tconst titleStr = title(data);\n\t\t\t\treturn `<li>\n\t\t\t\t\t<button type=\"button\" aria-controls=\"${controls}\" aria-label=\"${titleStr}\" title=\"${titleStr}\">\n\t\t\t\t\t\t<span>${labelStr}</span>\n\t\t\t\t\t</button>\n\t\t\t\t</li>`;\n\t\t\t}).join('')}\n\t\t</ul>\n\t`,\n\t/* eslint-enable indent */\n\n\tclassName: 'pagination',\n\tlabel: ({ index }) => `${index + 1}`,\n\ttitle: ({ index }) => `Go to ${index + 1}. page`,\n};\n\n\n/**\n * The feature to enable pagination controls.\n */\nexport class Pagination implements IFeature {\n\n\t/**\n\t * Creates an instance of this feature.\n\t * @param options are the options to configure this instance\n\t */\n\tconstructor(options: Options = {}) {\n\t\twriteCache(this, CACHE_KEY_CONFIGURATION, { ...DEFAULTS, ...options });\n\t\tthis._onClick = this._onClick.bind(this);\n\t}\n\n\t/**\n\t * Returns the name of this feature.\n\t */\n\tpublic get name(): typeof FEATURE_NAME {\n\t\treturn FEATURE_NAME;\n\t}\n\n\t/**\n\t * Initializes this feature. This function will be called by the carousel\n\t * instance and should not be called manually.\n\t * @internal\n\t * @param proxy the proxy instance between carousel and feature\n\t */\n\tpublic init(proxy: IProxy): void {\n\t\twriteCache(this, CACHE_KEY_PROXY, proxy);\n\t\tthis._add();\n\t}\n\n\t/**\n\t * Destroys this feature. This function will be called by the carousel instance\n\t * and should not be called manually.\n\t * @internal\n\t */\n\tpublic destroy(): void {\n\t\tthis._remove();\n\t\tclearFullCache(this);\n\t}\n\n\t/**\n\t * This triggers the feature to update its inner state. This function will be\n\t * called by the carousel instance and should not be called manually. The\n\t * carousel passes a event object that includes the update reason. This can be\n\t * used to selectively/partially update sections of the feature.\n\t * @internal\n\t * @param event event that triggered the update\n\t * @param event.type is the update reason (why this was triggered)\n\t */\n\tpublic update(event: UpdateEvent): void {\n\t\tswitch (event.type) {\n\t\t\tcase UpdateType.SCROLL:\n\t\t\t\tthis._update();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthis._remove();\n\t\t\t\tthis._add();\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * Renders and adds the pagination element. Attaches event handlers to all\n\t * button elements.\n\t * @internal\n\t */\n\tprivate _add(): void {\n\t\tconst proxy = fromCache<IProxy>(this, CACHE_KEY_PROXY) as IProxy;\n\t\tconst config = fromCache<Configuration>(this, CACHE_KEY_CONFIGURATION) as Configuration;\n\t\tconst { el, mask, pages } = proxy;\n\t\tconst target = mask ?? el;\n\n\t\tif (pages.length < 2) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst { template, className, label, title } = config;\n\t\tconst pagination = render(template, { label, title, pages, className, controls: el.id });\n\n\t\tif (!pagination) {\n\t\t\treturn;\n\t\t}\n\n\t\t// @TODO: Add template for buttons:\n\t\tconst buttons = Array.from(pagination.querySelectorAll<HTMLButtonElement>('button'))\n\t\t\t.map((button) => {\n\t\t\t\t// The onClick listener is already bound in the constructor.\n\t\t\t\t//\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/unbound-method\n\t\t\t\tbutton.addEventListener('click', this._onClick, true);\n\t\t\t\treturn button;\n\t\t\t});\n\n\t\ttarget.parentNode?.appendChild(pagination);\n\t\twriteCache(this, CACHE_KEY_PAGINATION, pagination);\n\t\twriteCache(this, CACHE_KEY_BUTTONS, buttons);\n\n\t\tthis._update();\n\t}\n\n\t/**\n\t * Updates the states of all buttons inside the pagination.\n\t * @internal\n\t */\n\tprivate _update(): void {\n\t\tconst proxy = fromCache<IProxy>(this, CACHE_KEY_PROXY) as IProxy;\n\t\tconst buttons = fromCache<HTMLButtonElement[]>(this, CACHE_KEY_BUTTONS);\n\n\t\tconst { pageIndex } = proxy;\n\t\tbuttons?.forEach((button, at) => button.disabled = (at === pageIndex));\n\t}\n\n\t/**\n\t * Removes the whole pagination element and removes all attached event handlers.\n\t * @internal\n\t */\n\tprivate _remove(): void {\n\t\tconst pagination = fromCache<HTMLElement>(this, CACHE_KEY_PAGINATION);\n\t\tconst buttons = fromCache<HTMLButtonElement[]>(this, CACHE_KEY_BUTTONS);\n\n\t\tbuttons?.forEach((button) => {\n\t\t\t// The onClick listener is already bound in the constructor.\n\t\t\t//\n\t\t\t// eslint-disable-next-line @typescript-eslint/unbound-method\n\t\t\tbutton.removeEventListener('click', this._onClick);\n\t\t\tbutton.parentNode?.removeChild(button);\n\t\t});\n\t\tpagination?.parentNode?.removeChild(pagination);\n\n\t\tclearCache(this, CACHE_KEY_BUTTONS);\n\t\tclearCache(this, CACHE_KEY_PAGINATION);\n\t}\n\n\t/**\n\t * Event handler when a button is clicked. Detects the current index of the\n\t * clicked button inside the pagination and updates the index accordingly of\n\t * the carousel.\n\t * @internal\n\t * @param event the mouse event\n\t */\n\tprivate _onClick(event: MouseEvent): void {\n\t\tconst proxy = fromCache<IProxy>(this, CACHE_KEY_PROXY) as IProxy;\n\t\tconst buttons = fromCache<HTMLButtonElement[]>(this, CACHE_KEY_BUTTONS);\n\t\tif (!buttons) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst target = event.currentTarget as HTMLButtonElement;\n\t\tconst index = buttons.indexOf(target);\n\t\tproxy.index = proxy.pages[index];\n\t}\n\n}\n"],"names":["modules","entry","mainEntry","parcelRequireName","globalName","globalObject","globalThis","self","window","global","previousRequire","cache","nodeRequire","module","require","bind","newRequire","name","jumped","currentRequire","err","Error","code","localRequire","resolve","x","id","Module","call","exports","res","isParcelRequire","moduleName","bundle","parent","register","Object","defineProperty","get","i","length","parcelHelpers","defineInteropFlag","export","_mask","Mask","Carousel","_proxy","_types","_cache","_debounce","ID_NAME","count","ID_MATCH","EVENT_SCROLL","EVENT_RESIZE","CACHE_KEY_ELEMENT","CACHE_KEY_CONFIGURATION","CACHE_KEY_INDEX","CACHE_KEY_ITEMS","CACHE_KEY_PAGES","CACHE_KEY_PAGE_INDEX","CACHE_KEY_MASK","CACHE_KEY_FEATURES","INVISIBLE_ELEMENTS","__instanceCount","DEFAULTS","features","filterItem","onScroll","undefined","resetInstanceCount","constructor","el","options","behavior","ScrollBehavior","AUTO","Element","writeCache","configuration","assign","mask","index","findIndex","feature","splice","filter","proxy","Proxy","forEach","init","Array","isArray","isNaN","SMOOTH","_onScroll","debounce","_onResize","addEventListener","fromCache","_a","items","clientWidth","outerLeft","getBoundingClientRect","left","at","rect","item","width","push","values","value","scrollLeft","to","Math","max","min","offsetLeft","pages","clearCache","scrollTo","children","from","test","tagName","hidden","viewport","map","sort","a","b","prevPage","firstItem","start","add","floor","page","pageIndex","visibles","reduce","acc","right","round","concat","rightA","rightB","includes","destroy","removeAttribute","removeEventListener","clearFullCache","update","type","UpdateType","FORCED","event","SCROLL","target","originalEvent","RESIZE","__scrollbar","_scrollbar","CACHE_KEY_PROXY","CACHE_KEY_HEIGHT","enabled","className","Scrollbar","_render","_remove","element","height","dimensions","scrollWidth","document","createElement","style","overflow","parentNode","insertBefore","appendChild","marginBottom","_b","removeChild","interopDefault","__esModule","default","exportAll","source","dest","keys","key","prototype","hasOwnProperty","enumerable","destName","cacheInstance","__CACHE","WeakMap","ref","factory","storage","Map","has","set","delete","CACHE_KEY_DIMENSIONS","inner","outer","body","position","top","visibility","h1","offsetHeight","h2","clientHeight","CACHE_KEY_INSTANCE","__getInstance","instance","sender","__getFeatures","FEATURE","func","delay","timeout","args","clearTimeout","setTimeout","Buttons","__rest","s","e","t","p","indexOf","getOwnPropertySymbols","propertyIsEnumerable","CACHE_KEY_BUTTONS","EVENT_CLICK","template","controls","label","title","nextClassName","nextLabel","nextTitle","previousClassName","previousLabel","previousTitle","_onPrev","_onNext","config","next","previous","settings","join","handler","params","button","render","nextSibling","lastPage","disabled","firstPage","buttons","context","innerHTML","firstElementChild","Mouse","CACHE_KEY_POSITION_X","CACHE_KEY_SCROLL_LEFT","CACHE_KEY_TIMEOUT","CURSOR_GRAB","EVENT_DRAG","EVENT_END","__getPositionX","MouseEvent","clientX","indicator","_onStart","_onDrag","_onEnd","cursor","passive","userSelect","scrollBehavior","scrollSnapType","onStart","_c","currentX","onDrag","_d","threshold","distance","currentLeft","offset","abs","removeProperty","requestAnimationFrame","onEnd","Pagination","CACHE_KEY_PAGINATION","data","labelStr","titleStr","_onClick","_add","_update","pagination","querySelectorAll","currentTarget"],"version":3,"file":"index.e0123caa.js.map"}