{"mappings":"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","sources":["src/carousel.ts","src/features/mask/index.ts","src/types.ts","node_modules/@parcel/transformer-js/src/esmodule-helpers.js","src/utils/cache.ts","src/features/mask/scrollbar.ts","src/proxy.ts","src/utils/debounce.ts","src/features/buttons/index.ts","src/utils/render.ts","src/features/mouse/index.ts","src/features/pagination/index.ts"],"sourcesContent":["import { Mask } from './features/mask';\nimport { Proxy } from './proxy';\nimport { FilterItemFn, ICarousel, IFeature, Index, Pages, ScrollBehavior, ScrollHook, UpdateType } from './types';\nimport { clearCache, clearFullCache, fromCache, writeCache } from './utils/cache';\nimport { debounce } from './utils/debounce';\n\n\nconst ID_NAME = (count: number) => `caroucssel-${count}`;\nconst ID_MATCH = /^caroucssel-[0-9]*$/;\n\nconst EVENT_SCROLL = 'scroll';\nconst EVENT_RESIZE = 'resize';\n\nconst CACHE_KEY_ELEMENT = 'element';\nconst CACHE_KEY_ID = 'id';\nconst CACHE_KEY_CONFIGURATION = 'config';\nconst CACHE_KEY_INDEX = 'index';\nconst CACHE_KEY_ITEMS = 'items';\nconst CACHE_KEY_PAGES = 'pages';\nconst CACHE_KEY_PAGE_INDEX = 'page-index';\nconst CACHE_KEY_MASK = 'mask';\nconst CACHE_KEY_PROXY = 'proxy';\nconst CACHE_KEY_FEATURES = 'feautres';\n\nconst VISIBILITY_OFFSET = 0.25;\nconst INVISIBLE_ELEMENTS = /^(link|meta|noscript|script|style|title)$/i;\n\n\n/**\n * Export the mask because it's used by default inside the carousel.\n */\nexport { Mask };\n\n\n/**\n * The available options for the carousel.\n */\nexport type Options = {\n\tindex?: Index | number;\n\tfeatures?: IFeature[],\n\tfilterItem?: FilterItemFn;\n\tonScroll?: ScrollHook;\n};\n\n\n/**\n * The required configuration of the carousel.\n * @internal\n */\nexport type Configuration = Omit<Required<Options>, 'index'>;\n\n\n/*\n * Internal counter for created instances. Will be used to create unique IDs.\n */\nlet __instanceCount = 0;\n\n\nconst DEFAULTS: Configuration = {\n\tfeatures: [],\n\tfilterItem: () => true,\n\tonScroll: () => undefined,\n};\n\n\n/**\n * The carousel instance.\n */\nexport class Carousel implements ICarousel {\n\n\t/**\n\t * This will be used for testing purposes to reset the instance count which is\n\t * used to create unique id's.\n\t * @internal\n\t */\n\tpublic static resetInstanceCount(): void {\n\t\t/* This should not be part of the coverage report: test util */\n\t\t/* istanbul ignore next */\n\t\tif (process.env.NODE_ENV === 'test') {\n\t\t\t__instanceCount = 0;\n\t\t}\n\t}\n\n\t/**\n\t * Current scroll behavior. Possible values are:\n\t * * `'auto'`\n\t * * `'smooth'`\n\t */\n\tpublic behavior: ScrollBehavior = ScrollBehavior.AUTO;\n\n\t/**\n\t * Creates an instance.\n\t * @param el is the dom element to control. This should be a container element\n\t * \tthat holds child elements that will scroll horizontally.\n\t * @param options are the options to configure this instance.\n\t */\n\tconstructor(el: Element, options: Options = {}) {\n\t\tif (!el || !(el instanceof Element)) {\n\t\t\tthrow new Error(`Carousel needs a dom element but \"${(typeof el)}\" was passed.`);\n\t\t}\n\n\t\twriteCache(this, CACHE_KEY_ELEMENT, el);\n\n\t\t// Count all created instances to create unique id, if given dom element\n\t\t// has no id-attribute:\n\t\t__instanceCount++;\n\t\tel.id = el.id || ID_NAME(__instanceCount);\n\t\twriteCache(this, CACHE_KEY_ID, el.id);\n\n\t\t// Extend options and defaults into configuration:\n\t\tconst configuration = { ...DEFAULTS, ...options };\n\t\twriteCache(this, CACHE_KEY_CONFIGURATION, configuration);\n\n\t\t// Detect if there is a \"Mask\" feature passed as option. Then use this one,\n\t\t// otherwise add a mandatory instance by default. Also ensure that only one\n\t\t// feature of type \"Mask\" is in the features list.\n\t\tlet mask: IFeature | null = null;\n\t\tlet features = [...configuration.features];\n\t\tconst index = configuration.features.findIndex((feature): boolean => feature instanceof Mask);\n\t\tif (index > -1) {\n\t\t\t// Extract first found instance of \"Mask\":\n\t\t\t[mask] = features.splice(index, 1);\n\t\t}\n\t\tmask ??= new Mask();\n\t\tfeatures = features.filter((feature): boolean => !(feature instanceof Mask));\n\t\tfeatures = [mask, ...features];\n\t\twriteCache(this, CACHE_KEY_MASK, mask);\n\n\t\t// Features: Initialize all features with a single proxy instance inbetween.\n\t\tconst proxy = new Proxy(this, features);\n\t\twriteCache(this, CACHE_KEY_PROXY, proxy);\n\t\twriteCache(this, CACHE_KEY_FEATURES, features);\n\t\tfeatures.forEach((feature) => feature.init(proxy));\n\n\t\t// Set initial index and finally set smooth scrolling to enabled:\n\t\tswitch (true) {\n\t\t\t// When index is a list:\n\t\t\tcase Array.isArray(options.index):\n\t\t\t\tthis.index = options.index as Index;\n\t\t\t\tbreak;\n\n\t\t\t// When index is a number, transfrom to list:\n\t\t\tcase !isNaN(options.index as number):\n\t\t\t\tthis.index = [options.index as number];\n\t\t\t\tbreak;\n\t\t}\n\t\tthis.behavior = ScrollBehavior.SMOOTH;\n\n\t\t// Debounced events:\n\t\t//\n\t\t// Where do these magic numbers come from? The numbers are the results of\n\t\t// testing the behavior in several browsers and are considered at \"best fit\"\n\t\t// without visible side effects to the UI. The value for the \"scroll\" event\n\t\t// correlates with the timing of scroll-behaviour: smooth.\n\t\t//\n\t\t// We disable @typescript-eslint/unbound-method here because we already bound\n\t\t// the functions while creating a debounced version. This would also cause\n\t\t// reference errors when tying to access these function references when used\n\t\t// with removeEventListeners() (see: destroy())\n\t\t//\n\t\t/* eslint-disable @typescript-eslint/unbound-method */\n\t\tthis._onScroll = debounce(this._onScroll.bind(this), 45);\n\t\tthis._onResize = debounce(this._onResize.bind(this), 25);\n\t\tel.addEventListener(EVENT_SCROLL, this._onScroll);\n\t\twindow.addEventListener(EVENT_RESIZE, this._onResize);\n\t\t/* eslint-enable @typescript-eslint/unbound-method */\n\t}\n\n\t/**\n\t * Returns the dom element reference of the carousel which was passed into the\n\t * constructor.\n\t * @public\n\t * @return the controlled dom element\n\t */\n\tpublic get el(): Element {\n\t\treturn fromCache<Element>(this, CACHE_KEY_ELEMENT) as Element;\n\t}\n\n\t/**\n\t * Returns the dom element reference of the mask element that wraps the\n\t * carousel element.\n\t * @public\n\t * @return the mask dom element\n\t */\n\tpublic get mask(): Element | null {\n\t\tconst mask = fromCache<Mask>(this, CACHE_KEY_MASK) as Mask;\n\t\treturn mask.el ?? null;\n\t}\n\n\t/**\n\t * Returns the id-attribute value of the carousel.\n\t * @public\n\t * @return the id of the controlled dom element\n\t */\n\tpublic get id(): string {\n\t\treturn fromCache<string>(this, CACHE_KEY_ID) as string;\n\t}\n\n\t/**\n\t * Returns the current index of the carousel. The returned index is a list (array)\n\t * of indexes that are currently visible (depending on each item width).\n\t * @public\n\t * @return a list of visible indexes\n\t */\n\tpublic get index(): Index {\n\t\treturn fromCache(this, CACHE_KEY_INDEX, (): Index => {\n\t\t\tconst { el, items } = this;\n\t\t\tconst { length } = items;\n\t\t\tconst { clientWidth } = el;\n\t\t\tconst outerLeft = el.getBoundingClientRect().left;\n\n\t\t\tconst index: number[] = [];\n\t\t\tlet at = 0;\n\n\t\t\tfor (;at < length; at++) {\n\t\t\t\tconst item = items[at];\n\t\t\t\tconst rect = item.getBoundingClientRect();\n\t\t\t\tconst { width } = rect;\n\t\t\t\tlet { left } = rect;\n\t\t\t\tleft = left - outerLeft;\n\n\t\t\t\tif (left + width * VISIBILITY_OFFSET >= 0 &&\n\t\t\t\t\tleft + width * (1 - VISIBILITY_OFFSET) <= clientWidth) {\n\t\t\t\t\tindex.push(at);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (index.length === 0) {\n\t\t\t\t// If no index found, we return a [0] as default. This possibly happens\n\t\t\t\t// when the carousel is not attached to the DOM or is visually hidden (display: none).\n\t\t\t\treturn [0];\n\t\t\t}\n\n\t\t\treturn index as Index;\n\t\t});\n\t}\n\n\t/**\n\t * Sets the current index of the carousel. To set an index you need to pass an\n\t * array with at least one element. When passing more than one, the rest will\n\t * be ignored.\n\t * @public\n\t * @param values are the upcoming indexes\n\t */\n\tpublic set index(values: Index) {\n\t\tconst { behavior, el, items } = this;\n\t\tconst { length } = items;\n\n\t\tif (!Array.isArray(values) || !values.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet value = values[0] || 0;\n\t\tvalue = Math.max(Math.min(value, length - 1), 0);\n\n\t\tconst { scrollLeft } = el;\n\t\tconst from = { left: scrollLeft };\n\t\tconst to = { left: items[value].offsetLeft };\n\n\t\t// If the target item is the first visible element in the list, ignore\n\t\t// the possible offset to the left and scroll to the beginning of the list:\n\t\tif (value === this.pages[0][0]) {\n\t\t\tto.left = 0;\n\t\t}\n\n\t\tif (from.left === to.left) {\n\t\t\treturn;\n\t\t}\n\n\t\tclearCache(this, CACHE_KEY_INDEX);\n\n\t\tel.scrollTo({ ...to, behavior });\n\t}\n\n\t/**\n\t * Returns an array of all child dom elements of the carousel.\n\t * @public\n\t * @return a list of elements (child elements of the root element)\n\t */\n\tpublic get items(): HTMLElement[] {\n\t\treturn fromCache(this, CACHE_KEY_ITEMS, (): HTMLElement[] => {\n\t\t\tconst { filterItem } = fromCache<Configuration>(this, CACHE_KEY_CONFIGURATION) as Configuration;\n\t\t\tconst { el } = this;\n\t\t\tconst children = Array.from(el.children) as HTMLElement[];\n\n\t\t\treturn children\n\t\t\t\t.filter((item) => !INVISIBLE_ELEMENTS.test(item.tagName) && !item.hidden)\n\t\t\t\t.filter(filterItem);\n\t\t});\n\t}\n\n\t/**\n\t * Returns an array of all pages. Each page is a group of indexes that matches\n\t * a page.\n\t * @public\n\t * @return the list of pages and indexes inside each page\n\t */\n\tpublic get pages(): Pages {\n\t\treturn fromCache(this, CACHE_KEY_PAGES, (): Pages => {\n\t\t\tconst { el, items } = this;\n\t\t\tconst { clientWidth: viewport } = el;\n\n\t\t\tif (viewport === 0) {\n\t\t\t\t// if the width of the carousel element is zero, we can not calculate\n\t\t\t\t// the pages properly and the carousel seems to be not visible. If\n\t\t\t\t// this is the case, we assume that each item is placed on a\n\t\t\t\t// separate page.\n\t\t\t\treturn items.map((item, index) => [index] as Index) as Pages;\n\t\t\t}\n\n\t\t\ttype Dataset = {\n\t\t\t\titem: HTMLElement;\n\t\t\t\tleft: number;\n\t\t\t\twidth: number;\n\t\t\t\tindex: number;\n\t\t\t};\n\n\t\t\tlet pages: Dataset[][] = [[]];\n\n\t\t\titems\n\t\t\t\t.map((item, index): Dataset => {\n\t\t\t\t\t// Create a re-usable dataset for each item:\n\t\t\t\t\tconst { offsetLeft: left, clientWidth: width } = item;\n\t\t\t\t\treturn { left, width, item, index };\n\t\t\t\t})\n\t\t\t\t.sort((a, b) => {\n\t\t\t\t\t// Create ordered list of items based on their visual ordering.\n\t\t\t\t\t// This may differ from the DOM ordering unsing css properties\n\t\t\t\t\t// like `order` in  flexbox or grid:\n\t\t\t\t\treturn a.left - b.left;\n\t\t\t\t})\n\t\t\t\t.forEach((item) => {\n\t\t\t\t\t// Calculate pages / page indexes for each item:\n\t\t\t\t\t//\n\t\t\t\t\t// The idea behind the calculation of the pages is to separate\n\t\t\t\t\t// the items by fitting them into the viewport of the carousel.\n\t\t\t\t\t// To behave correctly, we cannot divide the total length of the\n\t\t\t\t\t// carousel by the viewport to get the page indexes (naive approach).\n\t\t\t\t\t// However, since there may be items that are partially visible\n\t\t\t\t\t// on a page, but mathematically create a new page. The calculation\n\t\t\t\t\t// must start from this item again. This means that always the\n\t\t\t\t\t// first item on a page sets the basis for the calculation of\n\t\t\t\t\t// the following item and its belonging to the current or next\n\t\t\t\t\t// page:\n\t\t\t\t\tconst { left, width } = item;\n\n\t\t\t\t\tconst prevPage = pages[pages.length - 1];\n\t\t\t\t\tconst firstItem = prevPage[0];\n\t\t\t\t\tlet start = firstItem?.left || 0;\n\n\t\t\t\t\t// This is required for the first page. The first page always\n\t\t\t\t\t// needs to start from the left=0. Any offset from the\n\t\t\t\t\t// left of the first visual item needs to be ignored, otherwise\n\t\t\t\t\t// the calculation of visual pages is incorrect:\n\t\t\t\t\tif (prevPage === pages[0]) {\n\t\t\t\t\t\tstart = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\t// At least 75% of the items needs to be in the page. Calculate\n\t\t\t\t\t// the amount of new pages to add. If value is 0, the current\n\t\t\t\t\t// item fits into the previous page:\n\t\t\t\t\tlet add = Math.floor(((left - start) + width * (1 - VISIBILITY_OFFSET)) / viewport);\n\n\t\t\t\t\twhile(add > 0) {\n\t\t\t\t\t\tpages.push([]);\n\t\t\t\t\t\tadd--;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst page = pages[pages.length - 1];\n\t\t\t\t\tpage.push(item);\n\t\t\t\t});\n\n\t\t\t// Remove empty pages: this might happen if items are wider than the\n\t\t\t// carousel viewport:\n\t\t\tpages = pages.filter((page) => page.length !== 0);\n\n\t\t\t// Restructure pages to only contain the index of each item:\n\t\t\treturn pages.map((page) => page.map(({ index }) => index) as Index) as Pages;\n\t\t});\n\t}\n\n\t/**\n\t * Returns the index of the current page.\n\t * @public\n\t * @return the index of the current page\n\t */\n\tpublic get pageIndex(): number {\n\t\treturn fromCache(this, CACHE_KEY_PAGE_INDEX, (): number => {\n\t\t\tconst { el, items, index, pages } = this;\n\t\t\tconst outerLeft = el.getBoundingClientRect().left;\n\t\t\tconst { clientWidth } = el;\n\n\t\t\tlet visibles: number[] = index.reduce<number []>((acc, at) => {\n\t\t\t\tif (!items[at]) {\n\t\t\t\t\treturn acc;\n\t\t\t\t}\n\n\t\t\t\tlet { left, right } = items[at].getBoundingClientRect();\n\t\t\t\t// \"getBoundingClientRect()\" can return float numbers which\n\t\t\t\t// lead to an unwanted behavior when in the calculation with\n\t\t\t\t// \"clientWidth\" (not using floats). We use round here to\n\t\t\t\t// normalize those values...\n\t\t\t\tleft = Math.round(left - outerLeft);\n\t\t\t\tright = Math.round(right - outerLeft);\n\n\t\t\t\t// Remove items that partially hidden to the left or right:\n\t\t\t\tif (left < 0 || clientWidth < right) {\n\t\t\t\t\treturn acc;\n\t\t\t\t}\n\n\t\t\t\treturn acc.concat([at]);\n\t\t\t}, []);\n\n\t\t\t// There might be no possible candidates. This is the case when items\n\t\t\t// are wider than the element viewport. In this case we take the first\n\t\t\t// item which is currently visible in general (might be the only one):\n\t\t\tif (visibles.length === 0) {\n\t\t\t\tvisibles = [index[0]];\n\t\t\t}\n\n\t\t\t// Search for the visible item that is most aligned to the right. The\n\t\t\t// found item marks the current page...\n\t\t\tconst at = visibles.sort((a, b) => {\n\t\t\t\tconst rightA = items[a].getBoundingClientRect().right;\n\t\t\t\tconst rightB = items[b].getBoundingClientRect().right;\n\t\t\t\treturn rightB - rightA;\n\t\t\t})[0];\n\n\t\t\t// Find the page index where the current item index is located...\n\t\t\treturn pages.findIndex((page) => page.includes(at));\n\t\t});\n\t}\n\n\t/**\n\t * This completely deconstructs the carousel and returns the dom to its\n\t * initial state.\n\t * @public\n\t */\n\tpublic destroy(): void {\n\t\tconst { el } = this;\n\n\t\t// Remove created id if it was created by carousel:\n\t\tID_MATCH.test(el.id) && el.removeAttribute('id');\n\n\t\t// Destroy attached features:\n\t\tconst features = fromCache<IFeature[]>(this, CACHE_KEY_FEATURES) as IFeature[];\n\t\tfeatures.forEach((feature) => feature.destroy());\n\n\t\t// Remove events:\n\t\t//\n\t\t// We need to work the the function reference. Using .bind() would create a\n\t\t// new referenced instance of the callback function. We already created a\n\t\t// bound version of these function within the constructor.\n\t\t//\n\t\t/* eslint-disable @typescript-eslint/unbound-method */\n\t\tel.removeEventListener(EVENT_SCROLL, this._onScroll);\n\t\twindow.removeEventListener(EVENT_RESIZE, this._onResize);\n\t\t/* eslint-enable @typescript-eslint/unbound-method */\n\n\t\t// Clear cache:\n\t\tclearFullCache(this);\n\t}\n\n\t/**\n\t * Enforces an update of all enabled components of the carousel. This is, for\n\t * example, useful when changing the number of items inside the carousel. This\n\t * also forwards an update call to all attached features.\n\t * @public\n\t */\n\tpublic update(): void {\n\t\tclearCache(this, CACHE_KEY_INDEX);\n\t\tclearCache(this, CACHE_KEY_ITEMS);\n\t\tclearCache(this, CACHE_KEY_PAGES);\n\t\tclearCache(this, CACHE_KEY_PAGE_INDEX);\n\n\t\tconst features = fromCache<IFeature[]>(this, CACHE_KEY_FEATURES) as IFeature[];\n\t\tfeatures.forEach((feature) => feature.update({ type: UpdateType.FORCED }));\n\t}\n\n\tprotected _onScroll(event: Event): void {\n\t\tclearCache(this, CACHE_KEY_INDEX);\n\t\tclearCache(this, CACHE_KEY_PAGE_INDEX);\n\n\t\tconst features = fromCache<IFeature[]>(this, CACHE_KEY_FEATURES) as IFeature[];\n\t\tfeatures.forEach((feature) => feature.update({ type: UpdateType.SCROLL }));\n\n\t\tconst { index } = this;\n\t\tconst configuration = fromCache<Configuration>(this, CACHE_KEY_CONFIGURATION) as Configuration;\n\t\tconfiguration.onScroll<Carousel>({ index, type: EVENT_SCROLL, target: this, originalEvent: event });\n\t}\n\n\tprotected _onResize(): void {\n\t\tclearCache(this, CACHE_KEY_PAGES);\n\t\tclearCache(this, CACHE_KEY_INDEX);\n\t\tclearCache(this, CACHE_KEY_PAGE_INDEX);\n\n\t\tconst features = fromCache<IFeature[]>(this, CACHE_KEY_FEATURES) as IFeature[];\n\t\tfeatures.forEach((feature) => feature.update({ type: UpdateType.RESIZE }));\n\t}\n\n}\n","import { IFeature, IProxy, UpdateEvent, UpdateType } from '../../types';\nimport { clearCache, clearFullCache, fromCache, writeCache } from '../../utils/cache';\n\nimport { Scrollbar } from './scrollbar';\n\n\nconst FEATURE_NAME = 'buildin:mask';\n\nconst CACHE_KEY_PROXY = 'prxy';\nconst CACHE_KEY_CONFIGURATION = 'conf';\nconst CACHE_KEY_MASK = 'mask';\nconst CACHE_KEY_HEIGHT = 'hght';\n\n\n/**\n * The options for the mask and scrollbar features.\n */\nexport type Options = {\n\n\t/**\n\t * Enables/disables the rendering of the mask to hide (enabled) or show\n\t * (disabled) the browsers scrollbars.\n\t * @defaultValue `true`\n\t */\n\tenabled?: boolean;\n\n\t/**\n\t * The class name of the mask element that will wrap the carousel element.\n\t * @defaultValue `'caroucssel-mask'`\n\t */\n\tclassName?: string;\n\n\t/**\n\t * The tag name of the mask element that will wrap the carousel element.\n\t * @defaultValue `'div'`\n\t */\n\ttagName?: string;\n\n};\n\n\n/**\n * The required configuration for mask and scrollbar features.\n * @internal\n */\ntype Configuration = Required<Options>;\n\n\n/**\n * Singleton of scrollbar util. Is shared across all instances of carousel to\n * reduce redundant calculations.\n * @internal\n */\nlet __scrollbar: Scrollbar;\n\n\nconst DEFAULTS: Configuration = {\n\tenabled: true,\n\tclassName: 'caroucssel-mask',\n\ttagName: 'div',\n};\n\n\n/**\n * The feature to enable/disabled mask and scrollbar support. This feature will\n * be added by default to each carousel. Use this feature to customize the\n * default behaviour.\n */\nexport class Mask implements IFeature {\n\n\t/**\n\t * Creates an instance of this feature.\n\t * @param options are the options to configure this instance\n\t */\n\tconstructor(options: Options = {}) {\n\t\twriteCache(this, CACHE_KEY_CONFIGURATION, { ...DEFAULTS, ...options });\n\t}\n\n\t/**\n\t * Returns the name of this feature.\n\t */\n\tpublic get name(): typeof FEATURE_NAME {\n\t\treturn FEATURE_NAME;\n\t}\n\n\t/**\n\t * Returns the rendered element that wraps the carousel. If not enabled, this\n\t * returns `null`.\n\t * @return the mask element, otherwise `null` if disabled.\n\t */\n\tpublic get el(): Element | null {\n\t\treturn fromCache<Element>(this, CACHE_KEY_MASK) ?? null;\n\t}\n\n\t/**\n\t * Initializes this feature. This function will be called by the carousel\n\t * instance and should not be called manually.\n\t * @internal\n\t * @param proxy the proxy instance between carousel and feature\n\t */\n\tpublic init(proxy: IProxy): void {\n\t\twriteCache(this, CACHE_KEY_PROXY, proxy);\n\n\t\t// Create a singleton instance of scrollbar for all carousel instances:\n\t\t__scrollbar = __scrollbar ?? new Scrollbar();\n\n\t\tthis._render();\n\t}\n\n\t/**\n\t * Destroys this feature. This function will be called by the carousel instance\n\t * and should not be called manually.\n\t * @internal\n\t */\n\tpublic destroy(): void {\n\t\tthis._remove();\n\t\tclearFullCache(this);\n\t}\n\n\t/**\n\t * This triggers the feature to update its inner state. This function will be\n\t * called by the carousel instance and should not be called manually. The\n\t * carousel passes a event object that includes the update reason. This can be\n\t * used to selectively/partially update sections of the feature.\n\t * @internal\n\t * @param event event that triggered the update\n\t * @param event.reason is the update reason (why this was triggered)\n\t */\n\tpublic update(event: UpdateEvent): void {\n\t\tswitch (event.type) {\n\t\t\tcase UpdateType.RESIZE:\n\t\t\tcase UpdateType.FORCED:\n\t\t\t\tclearCache(this, CACHE_KEY_HEIGHT);\n\t\t\t\tthis._render();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthis._render();\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * Renders the mask element, wraps the carousel element and crops the\n\t * height of the browsers scrollbar.\n\t * @internal\n\t */\n\tprivate _render(): void {\n\t\tconst { enabled, className, tagName } = fromCache<Configuration>(this, CACHE_KEY_CONFIGURATION) as Configuration;\n\t\tif (!enabled) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst proxy = fromCache<IProxy>(this, CACHE_KEY_PROXY) as IProxy;\n\t\tconst element = proxy.el as HTMLElement | SVGElement;\n\t\tlet { height } = __scrollbar.dimensions;\n\n\t\tif (element.scrollWidth <= element.clientWidth) {\n\t\t\t// If the contents are not scrollable because their width are less\n\t\t\t// than the container, there will be no visible scrollbar. In this\n\t\t\t// case, the scrollbar height is 0:\n\t\t\theight = 0;\n\t\t}\n\n\t\t// Use fromCache factory to render mask element only once:\n\t\tfromCache<Element>(this, CACHE_KEY_MASK, () => {\n\t\t\tconst mask = document.createElement(tagName);\n\t\t\tmask.className = className;\n\t\t\tmask.style.overflow = 'hidden';\n\t\t\tmask.style.height = '100%';\n\t\t\telement.parentNode?.insertBefore(mask, element);\n\t\t\tmask.appendChild(element);\n\t\t\treturn mask;\n\t\t});\n\n\t\tconst cachedHeight = fromCache<number>(this, CACHE_KEY_HEIGHT);\n\t\tif (height === cachedHeight) {\n\t\t\treturn;\n\t\t}\n\n\t\twriteCache(this, CACHE_KEY_HEIGHT, height);\n\n\t\telement.style.height = `calc(100% + ${height}px)`;\n\t\telement.style.marginBottom = `${height * -1}px`;\n\t}\n\n\t/**\n\t * Removes the mask element and unwraps the carousel element.\n\t * @internal\n\t */\n\tprivate _remove(): void {\n\t\tconst { el } = fromCache<IProxy>(this, CACHE_KEY_PROXY) as IProxy;\n\t\tconst mask = fromCache<HTMLDivElement>(this, CACHE_KEY_MASK);\n\n\t\tmask?.parentNode?.insertBefore(el, mask);\n\t\tmask?.parentNode?.removeChild(mask);\n\t\tel.removeAttribute('style');\n\t}\n\n}\n","/**\n * The representation of all visual items in a carousel. The is at least one\n * item that is always visible. In cases (e.g. display: none) where visibility\n * is uncalculatable this is `[0]`.\n *\n * Each index represents the index of the child elements ({@link Carousel.items | see items})\n * inside the dom. The index of these elements inside the dom may not be\n * equivalent to the visual indexes (e.g. css flexbox-ordering or css grids).\n */\nexport type Index = [number, ...number[]];\n\n\n/**\n * The representation of item indexes grouped into pages. These pages are the\n * available entry points for control features like buttons and pagination.\n *\n * The indexes inside each grouped page is based on the visual order of the\n * child elements ({@link Carousel.items | see items}).\n *\n * For example:\n * ```\n *   <div class=\"carousel\">\n *     <div class=\"item\" style=\"width: 100%; order: 3\">Item 1</div>\n *     <div class=\"item\" style=\"width: 50%; order: 2\">Item 2</div>\n *     <div class=\"item\" style=\"width: 50%; order: 1\">Item 3</div>\n *   </div>\n * ```\n *\n * The pages representation would look like: `[[2], [1, 0]]` (see ordering and width)\n */\nexport type Pages = [Index, ...Index[]];\n\n\n/**\n * The minimal represenation of the carousel control properties.\n * @internal\n */\ninterface ICore {\n\tget id(): string;\n\tget el(): Element;\n\tget mask(): Element | null;\n\tget index(): Index;\n\tset index(value: Index);\n\tget items(): HTMLElement[];\n\tget pages(): Pages;\n\tget pageIndex(): number;\n}\n\n\n/**\n * The carousel interface.\n */\nexport interface ICarousel extends ICore {\n\tbehavior: ScrollBehavior;\n\tdestroy(): void;\n\tupdate(): void;\n}\n\n\n/**\n * The feature proxy interface.\n */\nexport interface IProxy extends ICore {\n\tupdate(sender: IFeature): void;\n}\n\n\n/**\n * The feature interface.\n */\nexport interface IFeature {\n\n\t/**\n\t * Each feature needs to return a constant name that identifies the plugin.\n\t * Build in features are using the prefix `buildin:`.\n\t */\n\tget name(): string;\n\n\t/**\n\t * Initializes this feature. This function will be called by the carousel\n\t * instance and should not be called manually.\n\t * @param proxy the proxy instance between carousel and feature\n\t */\n\tinit(proxy: IProxy): void;\n\n\t/**\n\t * Destroys this feature. This function will be called by the carousel instance\n\t * and should not be called manually.\n\t */\n\tdestroy(): void;\n\n\t/**\n\t * This triggers the feature to update its inner state. This function will be\n\t * called by the carousel instance and should not be called manually. The\n\t * carousel passes a data object that includes the update reason. This can be\n\t * used to selectively/partially update sections of the feature.\n\t * @param data dataset that triggered the update\n\t * @param data.reason is the update reason (why this was triggered)\n\t */\n\tupdate(data :UpdateEvent): void;\n}\n\n\n/**\n * The event that is passed into each feature.\n */\nexport type UpdateEvent = {\n\n\t/**\n\t * The reason why this update was triggered.\n\t */\n\ttype: UpdateType;\n\n};\n\n\n/**\n * Possible types of an update.\n */\nexport enum UpdateType {\n\tSCROLL = 'scroll',\n\tRESIZE = 'resize',\n\tFORCED = 'forced',\n\tFEATURE = 'feature',\n}\n\n\n/**\n * The browsers scroll behavior.\n * See {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollTo | scrollTo on MDN}\n */\nexport enum ScrollBehavior {\n\tAUTO = 'auto',\n\tSMOOTH = 'smooth',\n}\n\n\n/**\n * A function that can be used as callback on scroll events.\n */\nexport type ScrollHook = <T>(event: {\n\tindex: Index;\n\ttype: 'scroll';\n\ttarget: T;\n\toriginalEvent: Event;\n}) => void;\n\n\n/**\n * A filter function to filter specific child elements ({@link Carousel.items | see items})\n * of the carousel.\n */\nexport type FilterItemFn =\n\t((item: HTMLElement) => boolean) |\n\t((item: HTMLElement, index: number) => boolean) |\n\t((item: HTMLElement, index: number, array: HTMLElement[]) => boolean);\n","exports.interopDefault = function (a) {\n  return a && a.__esModule ? a : {default: a};\n};\n\nexports.defineInteropFlag = function (a) {\n  Object.defineProperty(a, '__esModule', {value: true});\n};\n\nexports.exportAll = function (source, dest) {\n  Object.keys(source).forEach(function (key) {\n    if (key === 'default' || key === '__esModule' || dest.hasOwnProperty(key)) {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function () {\n        return source[key];\n      },\n    });\n  });\n\n  return dest;\n};\n\nexports.export = function (dest, destName, get) {\n  Object.defineProperty(dest, destName, {\n    enumerable: true,\n    get: get,\n  });\n};\n","// The key of a WeakMap must be an object. There is no other type that matches\n// or is valid for @typescript-eslint.\n// eslint-disable-next-line @typescript-eslint/ban-types\ntype Reference = object;\n\ntype Storage = Map<string, unknown>;\n\nconst __CACHE = new WeakMap<Reference, Storage>();\n\n/**\n * Returns the cache entry by a specific key of a given reference. If the cache\n * is not filled and the key doesn't exisit this will retrun undefined.\n * @typeParam T is the type of the cached value\n * @param ref the reference\n * @param key the storage key\n * @returns the cached value or undefined\n */\nexport function fromCache<T = unknown>(ref: Reference, key: string): T | undefined;\n\n/**\n * Returns the cache entry by a specific key of a given reference. If the cache\n * is not filled and the key doesn't exisit, the factory function is called to\n * generate a value. This value will be cached and returned.\n * @typeParam T is the type of the cached value\n * @param ref the reference\n * @param key the storage key\n * @param factory the factory function\n * @returns the cached value\n */\nexport function fromCache<T = unknown>(ref: Reference, key: string, factory: () => T): T;\n\nexport function fromCache<T = unknown>(ref: Reference, key: string, factory?: () => T): T | undefined {\n\tconst storage = __CACHE.get(ref) || new Map<string, T>();\n\tif (storage.has(key)) {\n\t\treturn storage.get(key) as T;\n\t}\n\n\tif (!factory) {\n\t\treturn undefined;\n\t}\n\n\tconst value = factory();\n\tstorage.set(key, value);\n\t__CACHE.set(ref, storage);\n\treturn value;\n}\n\n/**\n * Explicitly writes a value into the cache.\n * @typeParam T is the type of the value to cache\n * @param ref the reference\n * @param key the storage key\n * @param value the value\n */\nexport function writeCache<T = unknown>(ref: Reference, key: string, value: T): void {\n\tconst storage = __CACHE.get(ref) || new Map<string, T>();\n\tstorage.set(key, value);\n\t__CACHE.set(ref, storage);\n}\n\n/**\n * Creates the cache entry by as specific key of a given reference.\n * @param ref the reference\n * @param key the storage key\n */\nexport function clearCache(ref: Reference, key: string): void {\n\tconst storage = __CACHE.get(ref);\n\tif (!storage || !storage.has(key)) {\n\t\treturn;\n\t}\n\n\tstorage.delete(key);\n}\n\n/**\n * Clears the full cache by a given reference.\n * @param ref the reference.\n */\nexport function clearFullCache(ref: Reference): void {\n\t__CACHE.delete(ref);\n}\n\n/**\n * This exposes the cache instance for test environments. Otherwise it will be null.\n * @internal\n */\n/* This should not be part of the coverage report: test util */\n/* istanbul ignore next */\nexport const cacheInstance = (process.env.NODE_ENV === 'test') ? __CACHE : null;\n","import { clearCache, fromCache } from '../../utils/cache';\n\n/**\n * Dataset of scrollbar dimensions\n * @internal\n */\nexport type ScrollbarDimensions = {\n\n\t/**\n\t * Vertical size of a scrollbar.\n\t */\n\theight: number,\n};\n\n\nconst CACHE_KEY_DIMENSIONS = 'dims';\n\n\n/**\n * Helper class for scrollbar features.\n * @internal\n */\nexport class Scrollbar {\n\n\t/**\n\t * Creates an instance.\n\t * @internal\n\t */\n\tconstructor() {\n\t\twindow.addEventListener('resize', () => {\n\t\t\tclearCache(this, CACHE_KEY_DIMENSIONS);\n\t\t});\n\t}\n\n\t/**\n\t * Calculates the dimensions of a scrollbar in the current browser. The result\n\t * of the computation will be cached for this instance.\n\t *\n\t * Inspired by https://gist.github.com/kflorence/3086552\n\t *\n\t * @return the dimensions of the scrollar\n\t */\n\tget dimensions(): ScrollbarDimensions {\n\t\treturn fromCache<ScrollbarDimensions>(this, CACHE_KEY_DIMENSIONS, () => {\n\t\t\tconst inner = document.createElement('div');\n\t\t\tconst outer = document.createElement('div');\n\n\t\t\tdocument.body.appendChild(outer);\n\t\t\touter.style.position = 'absolute';\n\t\t\touter.style.top = '0px';\n\t\t\touter.style.left = '0px';\n\t\t\touter.style.visibility = 'hidden';\n\t\t\touter.appendChild(inner);\n\n\t\t\t// Disabled, not needed for current feature set.\n\t\t\t//\n\t\t\t// Calculate width:\n\t\t\t// inner.style.width = '100%';\n\t\t\t// inner.style.height = '200px';\n\t\t\t// outer.style.width = '200px';\n\t\t\t// outer.style.height = '150px';\n\t\t\t// outer.style.overflow = 'hidden';\n\t\t\t// w1 = inner.offsetWidth;\n\t\t\t// outer.style.overflow = 'scroll';\n\t\t\t// w2 = inner.offsetWidth;\n\t\t\t// w2 = (w1 === w2) ? outer.clientWidth : w2;\n\t\t\t// width = w1 - w2;\n\n\t\t\t// Calculate height:\n\t\t\tinner.style.width = '200px';\n\t\t\tinner.style.height = '100%';\n\t\t\touter.style.width = '150px';\n\t\t\touter.style.height = '200px';\n\t\t\touter.style.overflow = 'hidden';\n\n\t\t\tconst h1 = inner.offsetHeight;\n\t\t\touter.style.overflow = 'scroll';\n\t\t\tlet h2 = inner.offsetHeight;\n\t\t\th2 = (h1 === h2) ? outer.clientHeight : h2;\n\t\t\tconst height = h1 - h2;\n\n\t\t\tdocument.body.removeChild(outer);\n\n\t\t\treturn {\n\t\t\t\t// width,\n\t\t\t\theight,\n\t\t\t};\n\t\t});\n\t}\n\n}\n","import { ICarousel, IFeature, Index, IProxy, Pages, UpdateType } from \"./types\";\nimport { fromCache, writeCache } from './utils/cache';\n\n\nconst CACHE_KEY_INSTANCE = 'inst';\nconst CACHE_KEY_FEATURES = 'feat';\n\n\n/**\n * Helper to access the instance cache.\n * @internal\n */\nfunction __getInstance(ref: Proxy): ICarousel {\n\treturn fromCache<ICarousel>(ref, CACHE_KEY_INSTANCE) as ICarousel;\n}\n\n\n/**\n * Helper to access the features cache.\n * @internal\n */\nfunction __getFeatures(ref: Proxy): IFeature[] {\n\treturn fromCache<IFeature[]>(ref, CACHE_KEY_FEATURES) as IFeature[];\n}\n\n/**\n * A proxy instance between carousel and a feature. Restricts the access for\n * features to the carousel instance.\n */\nexport class Proxy implements IProxy {\n\n\t/**\n\t * Creates an instance of the proxy.\n\t * @param instance the carousel instance to proxy the access to.\n\t * @param features all the features that should access the carousel through this instance.\n\t */\n\tconstructor(instance: ICarousel, features: IFeature[]) {\n\t\twriteCache(this, CACHE_KEY_INSTANCE, instance);\n\t\twriteCache(this, CACHE_KEY_FEATURES, features);\n\t}\n\n\t/**\n\t * Proxies the {@link Carousel.id | `id`} getter of the carousel.\n\t */\n\tpublic get id(): string {\n\t\treturn __getInstance(this).id;\n\t}\n\n\t/**\n\t * Proxies the {@link Carousel.el | `el`} getter of the carousel.\n\t */\n\tpublic get el(): Element {\n\t\treturn __getInstance(this).el;\n\t}\n\n\t/**\n\t * Proxies the {@link Carousel.mask | `mask`} getter of the carousel.\n\t */\n\tpublic get mask(): Element | null {\n\t\treturn __getInstance(this).mask;\n\t}\n\n\t/**\n\t * Proxies the {@link Carousel.index | `index`} getter of the carousel.\n\t */\n\tpublic get index(): Index {\n\t\treturn __getInstance(this).index;\n\t}\n\n\t/**\n\t * Proxies the {@link Carousel.index | `index`} setter of the carousel.\n\t */\n\tpublic set index(value: Index) {\n\t\t__getInstance(this).index = value;\n\t}\n\n\t/**\n\t * Proxies the {@link Carousel.items | `items`} getter of the carousel.\n\t */\n\tpublic get items(): HTMLElement[] {\n\t\treturn __getInstance(this).items;\n\t}\n\n\t/**\n\t * Proxies the {@link Carousel.pages | `pages`} getter of the carousel.\n\t */\n\tpublic get pages(): Pages {\n\t\treturn __getInstance(this).pages;\n\t}\n\n\t/**\n\t * Proxies the {@link Carousel.pagesIndex | `pagesIndex`} getter of the carousel.\n\t */\n\tpublic get pageIndex(): number {\n\t\treturn __getInstance(this).pageIndex;\n\t}\n\n\t/**\n\t * Function to trigger an update from a feature. This will send an update to\n\t * the carousel instance and all other attached features exept the sender.\n\t * @param sender feature that triggers the update.\n\t */\n\tpublic update(sender: IFeature): void {\n\t\t__getInstance(this).update();\n\n\t\t// Trigger update in all other features except the source feature that\n\t\t// triggered the event:\n\t\t__getFeatures(this).forEach((feature): void => {\n\t\t\tif (feature === sender) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfeature.update({ type: UpdateType.FEATURE });\n\t\t});\n\t}\n\n}\n","// See: https://codeburst.io/throttling-and-debouncing-in-javascript-b01cad5c8edf\n\n\n/**\n * Generic function\n */\nexport type Source = (...args: never[]) => unknown;\n\n\n/**\n * Debounced function\n * @typeParam F is the shape of the original function.\n */\nexport type Debounced<F extends Source> = (...args: Parameters<F>) => void;\n\n\n/**\n * Creates a debounced version for a given function in a given delay (in ms).\n * @typeParam F is the shape of the function to debounce.\n * @param func the original function\n * @param delay the delay in milliseconds (ms)\n * @returns the debounced function\n */\nexport function debounce<F extends Source>(func: F, delay: number): Debounced<F> {\n\tlet timeout: ReturnType<typeof setTimeout> | null = null;\n\tconst debounced = (...args: Parameters<F>) => {\n\t\tif (timeout !== null) {\n\t\t\tclearTimeout(timeout);\n\t\t}\n\n\t\ttimeout = setTimeout(() => func(...args), delay);\n\t};\n\n\treturn debounced;\n}\n","import { IFeature, IProxy } from '../../types';\nimport { clearFullCache, fromCache, writeCache } from '../../utils/cache';\nimport { render } from '../../utils/render';\n\n\nconst FEATURE_NAME = 'buildin:buttons';\n\nconst CACHE_KEY_PROXY = 'prxy';\nconst CACHE_KEY_CONFIGURATION = 'conf';\nconst CACHE_KEY_BUTTONS = 'btns';\n\nconst EVENT_CLICK = 'click';\n\n\n/**\n * The template function to render a HTML markup of a button.\n * @param context the template context containing the required data to render\n * @return the HTML markup\n */\nexport type Template = (context: Context) => string;\n\n\n/**\n * The template rendering context.\n */\nexport type Context = {\n\tcontrols: string;\n\tclassName: string;\n\tlabel: string;\n\ttitle: string;\n};\n\n\n/**\n * Short type of HTMLButtonElement or nullish (not rendered).\n * @interal\n */\ntype Button = HTMLButtonElement | null;\n\n\n/**\n * The options for the buttons feature.\n */\nexport type Options = {\n\t/**\n\t * Render function for a single button.\n\t */\n\ttemplate?: Template;\n\n\t/**\n\t * The shared class name for both buttons (next and previous).\n\t * @defaultValue `'button'`\n\t */\n\tclassName?: string;\n\n\t/**\n\t * The class name of the next button.\n\t * @defaultValue `'is-next'`\n\t */\n\tnextClassName?: string;\n\n\t/**\n\t * The text label of the next button.\n\t * @defaultValue `'Next'`\n\t */\n\tnextLabel?: string;\n\n\t/**\n\t * The title attribute value of the next button.\n\t * @defaultValue `'Go to next'`\n\t */\n\tnextTitle?: string;\n\n\t/**\n\t * The class name of the previous button.\n\t * @defaultValue `'is-previous'`\n\t */\n\tpreviousClassName?: string;\n\n\t/**\n\t * The text label of the previous button.\n\t * @defaultValue `'Previous'`\n\t */\n\tpreviousLabel?: string;\n\n\t/**\n\t * The title attribute value of the previous button.\n\t * @defaultValue `'Go to previous'`\n\t */\n\tpreviousTitle?: string;\n\n};\n\n\n/**\n * The required configuration for buttons feature.\n * @internal\n */\ntype Configuration = Required<Options>;\n\n\nconst DEFAULTS: Configuration = {\n\ttemplate: ({ className, controls, label, title }: Context) => `\n\t\t<button type=\"button\" class=\"${className}\" aria-label=\"${label}\" title=\"${title}\" aria-controls=\"${controls}\">\n\t\t\t<span>${label}</span>\n\t\t</button>\n\t`,\n\tclassName: 'button',\n\n\tnextClassName: 'is-next',\n\tnextLabel: 'Next',\n\tnextTitle: 'Go to next',\n\n\tpreviousClassName: 'is-previous',\n\tpreviousLabel: 'Previous',\n\tpreviousTitle: 'Go to previous',\n};\n\n\n/**\n * The feature to enable button controls (next and previous) for a carousel.\n */\nexport class Buttons implements IFeature {\n\n\t/**\n\t * Creates an instance of this feature.\n\t * @param options are the options to configure this instance\n\t */\n\tconstructor(options: Options = {}) {\n\t\twriteCache(this, CACHE_KEY_CONFIGURATION, { ...DEFAULTS, ...options });\n\t\tthis._onPrev = this._onPrev.bind(this);\n\t\tthis._onNext = this._onNext.bind(this);\n\t}\n\n\t/**\n\t * Returns the name of this feature.\n\t */\n\tpublic get name(): typeof FEATURE_NAME {\n\t\treturn FEATURE_NAME;\n\t}\n\n\t/**\n\t * Initializes this feature. This function will be called by the carousel\n\t * instance and should not be called manually.\n\t * @internal\n\t * @param proxy the proxy instance between carousel and feature\n\t */\n\tpublic init(proxy: IProxy): void {\n\t\twriteCache(this, CACHE_KEY_PROXY, proxy);\n\t\tthis._render();\n\t}\n\n\t/**\n\t * Destroys this feature. This function will be called by the carousel instance\n\t * and should not be called manually.\n\t * @internal\n\t */\n\tpublic destroy(): void {\n\t\tthis._remove();\n\t\tclearFullCache(this);\n\t}\n\n\t/**\n\t * This triggers the feature to update its inner state. This function will be\n\t * called by the carousel instance and should not be called manually. The\n\t * carousel passes a event object that includes the update reason. This can be\n\t * used to selectively/partially update sections of the feature.\n\t * @internal\n\t */\n\tpublic update(/* event :UpdateEvent */): void {\n\t\tthis._render();\n\t}\n\n\t/**\n\t * Renders and update the button elements. Buttons will only be rendered once\n\t * and then loaded from cache. When calling this function twice or more, the\n\t * button states will be updated based on the scroll position.\n\t * @internal\n\t */\n\tprivate _render(): void {\n\t\tconst proxy = fromCache<IProxy>(this, CACHE_KEY_PROXY) as IProxy;\n\t\tconst config = fromCache<Configuration>(this, CACHE_KEY_CONFIGURATION) as Configuration;\n\n\t\tconst { el, mask, pages, pageIndex } = proxy;\n\n\t\t// Render buttons only once. Load them from cache if already rendered and\n\t\t// attached to the dom:\n\t\tconst [next, previous] = fromCache<Button[]>(\n\t\t\tthis, CACHE_KEY_BUTTONS, () => {\n\t\t\t\tconst target = mask ?? el;\n\t\t\t\tconst {\n\t\t\t\t\ttemplate, className,\n\t\t\t\t\tpreviousClassName, previousLabel, previousTitle,\n\t\t\t\t\tnextClassName, nextLabel, nextTitle,\n\t\t\t\t} = config;\n\n\t\t\t\t// Create button elements:\n\t\t\t\tconst settings = [\n\t\t\t\t\t{\n\t\t\t\t\t\tcontrols: el.id,\n\t\t\t\t\t\tlabel: nextLabel,\n\t\t\t\t\t\ttitle: nextTitle,\n\t\t\t\t\t\tclassName: [className, nextClassName].join(' '),\n\t\t\t\t\t\t// The onClick listener is already bound in the constructor.\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/unbound-method\n\t\t\t\t\t\thandler: this._onNext,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tcontrols: el.id,\n\t\t\t\t\t\tlabel: previousLabel,\n\t\t\t\t\t\ttitle: previousTitle,\n\t\t\t\t\t\tclassName: [className, previousClassName].join(' '),\n\t\t\t\t\t\t// The onClick listener is already bound in the constructor.\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/unbound-method\n\t\t\t\t\t\thandler: this._onPrev,\n\t\t\t\t\t},\n\t\t\t\t];\n\n\t\t\t\treturn settings.map(({ handler, ...params }) => {\n\t\t\t\t\tconst button = render<HTMLButtonElement, Context>(template, params);\n\t\t\t\t\tif (!button) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\tbutton.addEventListener(EVENT_CLICK, handler);\n\t\t\t\t\ttarget.parentNode?.insertBefore(button, target.nextSibling);\n\t\t\t\t\treturn button;\n\t\t\t\t});\n\t\t\t},\n\t\t);\n\n\t\tif (next) {\n\t\t\tconst lastPage = pages[pageIndex + 1];\n\t\t\tconst isLastPage = lastPage === undefined;\n\t\t\tnext.disabled = isLastPage;\n\t\t}\n\n\t\tif (previous) {\n\t\t\tconst firstPage = pages[pageIndex - 1];\n\t\t\tconst isFirstPage = firstPage === undefined;\n\t\t\tprevious.disabled = isFirstPage;\n\t\t}\n\t}\n\n\t/**\n\t * Removes all buttons from the dom and detaches all event handler.\n\t * @internal\n\t */\n\tprivate _remove(): void {\n\t\tconst buttons = fromCache<Button[]>(this, CACHE_KEY_BUTTONS);\n\n\t\tbuttons?.forEach((button): void => {\n\t\t\t// The onClick listener is already bound in the constructor.\n\t\t\t//\n\t\t\t// eslint-disable-next-line @typescript-eslint/unbound-method\n\t\t\tbutton?.removeEventListener(EVENT_CLICK, this._onPrev);\n\t\t\t// The onClick listener is already bound in the constructor.\n\t\t\t//\n\t\t\t// eslint-disable-next-line @typescript-eslint/unbound-method\n\t\t\tbutton?.removeEventListener(EVENT_CLICK, this._onNext);\n\t\t\tbutton?.parentNode?.removeChild(button);\n\t\t});\n\t}\n\n\t/**\n\t * Event handler to navigate backwards (to the left).\n\t * @internal\n\t */\n\tprivate _onPrev(): void {\n\t\tconst proxy = fromCache<IProxy>(this, CACHE_KEY_PROXY) as IProxy;\n\t\tconst { pages, pageIndex } = proxy;\n\t\tconst index = pages[pageIndex - 1] || pages[0];\n\t\tproxy.index = index;\n\t}\n\n\t/**\n\t * Event handler to navigate forwards (to the right).\n\t * @internal\n\t */\n\tprivate _onNext(): void {\n\t\tconst proxy = fromCache<IProxy>(this, CACHE_KEY_PROXY) as IProxy;\n\t\tconst { pages, pageIndex } = proxy;\n\t\tconst index = pages[pageIndex + 1] || pages[pages.length - 1];\n\t\tproxy.index = index;\n\t}\n\n}\n","/**\n * Renders a template (function) to into an HTML element. The template needs to\n * return a valid HTML string (with a single root element). A context with\n * key/value pairs will be passed into the template to allow dynamic rendering.\n * @typeParam El is the type of the rendered dom element.\n * @typeParam Context is the shape of the context data object\n * @param template a function to render a template\n * @param context context data for the template\n * @returns the rendered htmml element\n */\nexport function render<El = HTMLElement, Context = Record<string, unknown>>(\n\ttemplate: (context: Context) => string,\n\tcontext: Context,\n): El | null {\n\tconst el = document.createElement('div');\n\tel.innerHTML = template(context);\n\n\tconst ref = el.firstElementChild;\n\tif (!ref) {\n\t\treturn null;\n\t}\n\n\treturn ref as unknown as El;\n}\n","import { IFeature, IProxy } from '../../types';\nimport { clearCache, clearFullCache, fromCache, writeCache } from '../../utils/cache';\n\n\nconst FEATURE_NAME = 'buildin:mouse';\n\nconst CACHE_KEY_PROXY = 'prxy';\nconst CACHE_KEY_CONFIGURATION = 'conf';\nconst CACHE_KEY_PAGE_INDEX = 'pgidx';\nconst CACHE_KEY_POSITION_X = 'posx';\nconst CACHE_KEY_SCROLL_LEFT = 'scrl';\nconst CACHE_KEY_TIMEOUT = 'time';\n\nconst CURSOR_GRAB = 'grab';\nconst CURSOR_GRABBING = 'grabbing';\n\nconst EVENT_START = 'mousedown';\nconst EVENT_DRAG = 'mousemove';\nconst EVENT_END = 'mouseup';\n\nconst THRESHOLD_MIN = 100;\nconst THRESHOLD_MAX = 250;\nconst THRESHOLD_FACTOR = 0.25; // Relative carousel element width\n\n\n// We are ignoring this due to this whole feature is only here to make TS happy.\n/* istanbul ignore next */\n/**\n * Extracts the client x position from an event depending on the event type.\n * @internal\n * @param event the event\n * @returns the client x position\n */\nfunction __getPositionX(event: Event): number {\n\tif (event instanceof MouseEvent) {\n\t\treturn event.clientX;\n\t}\n\n\treturn 0;\n}\n\n\n/**\n * The options for the pagination feature.\n */\nexport type Options = {\n\n\t/**\n\t * Show a drag indicator using css cursor properties (grab and grabbing).\n\t */\n\tindicator?: boolean;\n\n\t/**\n\t * A hook function that is called when the user stats to drag.\n\t */\n\tonStart?: ((event: HookEvent) => void);\n\n\t/**\n\t * A hook function that is called when the user is dragging.\n\t */\n\tonDrag?: ((event: HookEvent) => void);\n\n\t/**\n\t * A hook function that is called when the user stops to drag.\n\t */\n\tonEnd?: ((event: HookEvent) => void);\n\n};\n\n/**\n * The event object that is passed for each hook.\n */\nexport type HookEvent = {\n\toriginalEvent: Event,\n};\n\n/**\n * The keys in the options that are hooks.\n * @internal\n */\ntype Hooks = 'onStart' | 'onDrag' | 'onEnd';\n\n\n/**\n * The required configuration for pagination feature.\n * @internal\n */\ntype Configuration =\n\tOmit<Required<Options>, Hooks> &\n\tOmit<Options, Exclude<keyof Options, Hooks>>;\n\n\nconst DEFAULTS: Configuration = {\n\tindicator: false,\n};\n\n\n/**\n * Feature to enable mouse controls\n */\nexport class Mouse implements IFeature {\n\n\t/**\n\t * Creates an instance of this feature.\n\t * @param options are the options to configure this instance\n\t */\n\tconstructor(options: Options = {}) {\n\t\twriteCache(this, CACHE_KEY_CONFIGURATION, { ...DEFAULTS, ...options });\n\t\tthis._onStart = this._onStart.bind(this);\n\t\tthis._onDrag = this._onDrag.bind(this);\n\t\tthis._onEnd = this._onEnd.bind(this);\n\t}\n\n\t/**\n\t * Returns the name of this feature.\n\t */\n\tget name(): typeof FEATURE_NAME {\n\t\treturn FEATURE_NAME;\n\t}\n\n\t/**\n\t * Initializes this feature. This function will be called by the carousel\n\t * instance and should not be called manually.\n\t * @internal\n\t * @param proxy the proxy instance between carousel and feature\n\t */\n\tpublic init(proxy: IProxy): void {\n\t\twriteCache(this, CACHE_KEY_PROXY, proxy);\n\n\t\tconst config = fromCache<Configuration>(this, CACHE_KEY_CONFIGURATION) as Configuration;\n\t\tconst { el } = proxy;\n\t\tconst element = el as HTMLElement;\n\t\telement.style.cursor = config.indicator ? CURSOR_GRAB : '';\n\n\t\t// The handler is already bound in the constructor.\n\t\t//\n\t\t// eslint-disable-next-line @typescript-eslint/unbound-method\n\t\tel.addEventListener(EVENT_START, this._onStart, { passive: true });\n\t}\n\n\t/**\n\t * Destroys this feature. This function will be called by the carousel instance\n\t * and should not be called manually.\n\t * @internal\n\t */\n\tpublic destroy(): void {\n\t\tclearFullCache(this);\n\t}\n\n\t/**\n\t * This triggers the feature to update its inner state. This function will be\n\t * called by the carousel instance and should not be called manually. The\n\t * carousel passes a event object that includes the update reason. This can be\n\t * used to selectively/partially update sections of the feature.\n\t * @internal\n\t */\n\tpublic update(): void {\n\t\t/* nothing to update yet */\n\t}\n\n\t/**\n\t * Handles the drag start event.\n\t * @internal\n\t * @param event the event that triggered the drag start\n\t */\n\tprivate _onStart(event: Event): void {\n\t\tconst timeout = fromCache<number>(this, CACHE_KEY_TIMEOUT);\n\t\tclearTimeout(timeout);\n\n\t\tconst config = fromCache<Configuration>(this, CACHE_KEY_CONFIGURATION) as Configuration;\n\t\tconst proxy = fromCache<IProxy>(this, CACHE_KEY_PROXY) as IProxy;\n\t\tconst element = proxy.el as HTMLElement;\n\t\tfromCache(this, CACHE_KEY_SCROLL_LEFT, (): number => element.scrollLeft);\n\t\tfromCache(this, CACHE_KEY_POSITION_X, (): number => __getPositionX(event));\n\t\tfromCache(this, CACHE_KEY_PAGE_INDEX, (): number => proxy.pageIndex);\n\n\t\t// Reset scroll behavior and scroll snapping to emulate regular scrolling.\n\t\t// Prevent user selection while the user drags:\n\t\telement.style.userSelect = 'none';\n\t\telement.style.scrollBehavior = 'auto';\n\t\telement.style.scrollSnapType = 'none';\n\t\telement.style.cursor = config.indicator ? CURSOR_GRABBING : '';\n\n\t\t// The handlers are already bound in the constructor.\n\t\t//\n\t\t/* eslint-disable @typescript-eslint/unbound-method */\n\t\twindow.addEventListener(EVENT_DRAG, this._onDrag, { passive: true });\n\t\twindow.addEventListener(EVENT_END, this._onEnd, { passive: true });\n\t\t/* eslint-enable @typescript-eslint/unbound-method */\n\n\t\t// Call the hook:\n\t\tconfig.onStart?.({ originalEvent: event });\n\t}\n\n\t/**\n\t * Handles the drag event. Calculates and updates scroll position.\n\t * @internal\n\t * @param event the event that triggered the dragging\n\t */\n\tprivate _onDrag(event: Event): void {\n\t\tconst config = fromCache<Configuration>(this, CACHE_KEY_CONFIGURATION) as Configuration;\n\t\tconst { el } = fromCache<IProxy>(this, CACHE_KEY_PROXY) as IProxy;\n\t\tconst left = fromCache<number>(this, CACHE_KEY_SCROLL_LEFT) ?? 0;\n\t\tconst x = fromCache<number>(this, CACHE_KEY_POSITION_X) ?? 0;\n\t\tconst currentX = __getPositionX(event);\n\t\tconst deltaX = x - currentX;\n\n\t\tel.scrollLeft = left + deltaX;\n\n\t\t// Call the hook:\n\t\tconfig.onDrag?.({ originalEvent: event });\n\t}\n\n\t/**\n\t * Handles the drag end event.\n\t * @internal\n\t * @param event the event that triggered the drag end\n\t */\n\tprivate _onEnd(event: Event): void {\n\t\tconst proxy = fromCache<IProxy>(this, CACHE_KEY_PROXY) as IProxy;\n\t\tconst config = fromCache<Configuration>(this, CACHE_KEY_CONFIGURATION) as Configuration;\n\t\tconst left = fromCache<number>(this, CACHE_KEY_SCROLL_LEFT) ?? 0;\n\t\tconst pageIndex = fromCache<number>(this, CACHE_KEY_PAGE_INDEX) ?? 0;\n\t\tclearCache(this, CACHE_KEY_SCROLL_LEFT);\n\t\tclearCache(this, CACHE_KEY_POSITION_X);\n\t\tclearCache(this, CACHE_KEY_PAGE_INDEX);\n\n\t\tconst element = proxy.el as HTMLElement;\n\t\tconst threshold = Math.min(Math.max(THRESHOLD_MIN, element.clientWidth * THRESHOLD_FACTOR), THRESHOLD_MAX);\n\t\tconst currentLeft = element.scrollLeft;\n\t\tconst distance = currentLeft - left;\n\t\tconst offset = Math.abs(distance);\n\n\t\telement.style.removeProperty('user-select');\n\t\telement.style.removeProperty('scroll-behavior');\n\t\telement.style.cursor = config.indicator ? CURSOR_GRAB : '';\n\n\t\t// Apply the index. If the scroll offset is higher that the threshold,\n\t\t// navigate to the next page depending on the drag direction.\n\t\tlet index = proxy.index;\n\t\tif (offset > threshold) {\n\t\t\tconst direction = distance / offset;\n\t\t\tconst at = Math.max(pageIndex + direction, 0);\n\t\t\tindex = proxy.pages[at] ?? index;\n\t\t}\n\n\t\t// Apply the index until the styles are rendered to the element. This is\n\t\t// required to have a smooth scroll-behaviour which is disabled during the\n\t\t// mouse dragging.\n\t\twindow.requestAnimationFrame(() => {\n\t\t\tproxy.index = index;\n\t\t});\n\n\t\t// Get around the scroll-snapping. Enable it until the position is already\n\t\t// applied. This will take ~1000ms depending on distance and browser\n\t\t// behaviour.\n\t\tconst timeout = window.setTimeout(() => {\n\t\t\telement.style.removeProperty('scroll-snap-type');\n\t\t}, 1000);\n\n\t\twriteCache(this, CACHE_KEY_TIMEOUT, timeout);\n\n\t\t// The handlers are already bound in the constructor.\n\t\t//\n\t\t/* eslint-disable @typescript-eslint/unbound-method */\n\t\twindow.removeEventListener(EVENT_DRAG, this._onDrag);\n\t\twindow.removeEventListener(EVENT_END, this._onEnd);\n\t\t/* eslint-enable @typescript-eslint/unbound-method */\n\n\t\t// Call the hook:\n\t\tconfig.onEnd?.({ originalEvent: event });\n\t}\n\n}\n","import { IFeature, IProxy, UpdateEvent, UpdateType } from '../../types';\nimport { clearCache, clearFullCache, fromCache, writeCache } from '../../utils/cache';\nimport { render } from '../../utils/render';\n\n\nconst FEATURE_NAME = 'buildin:pagination';\n\nconst CACHE_KEY_PROXY = 'prxy';\nconst CACHE_KEY_CONFIGURATION = 'conf';\nconst CACHE_KEY_PAGINATION = 'pags';\nconst CACHE_KEY_BUTTONS = 'btns';\n\n\n/**\n * The template function to render a HTML markup of a pagination.\n * @param context the template context containing the required data to render\n * @return the HTML markup\n */\nexport type Template = (params: Context) => string;\n\n\n/**\n * The template rendering context.\n */\nexport type Context = {\n\tcontrols: string;\n\tclassName: string;\n\tlabel: TextTemplate;\n\ttitle: TextTemplate;\n\tpages: number[][];\n};\n\n\n/**\n * A text template function to render a text node. This will be used for button\n * labels and text-attributes inside the pagination\n */\nexport type TextTemplate = (params: TextContext) => string;\n\n\n/**\n * The text template rendering context.\n */\nexport type TextContext = {\n\tindex: number;\n\tpage: number[];\n\tpages: number[][];\n};\n\n\n/**\n * The options for the pagination feature.\n */\nexport type Options = {\n\n\t/**\n\t * Render function for the pagination elemements.\n\t */\n\ttemplate?: Template;\n\n\t/**\n\t * The class name the pagination element.\n\t * @defaultValue `'pagination'`\n\t */\n\tclassName?: string;\n\n\t/**\n\t * Render function for each button label inside the pagination.\n\t */\n\tlabel?: TextTemplate;\n\n\t/**\n\t * Render function for each button title attribute inside the pagination.\n\t */\n\ttitle?: TextTemplate;\n\n};\n\n\n/**\n * The required configuration for pagination feature.\n * @internal\n */\ntype Configuration = Required<Options>;\n\nconst DEFAULTS: Configuration = {\n\t// @TODO: ESLint don't like the nested template literals and loops.\n\t/* eslint-disable indent */\n\ttemplate: ({ className, controls, pages, label, title }: Context) => `\n\t\t<ul class=\"${className}\">\n\t\t\t${pages.map((page, index) => {\n\t\t\t\tconst data = { index, page, pages };\n\t\t\t\tconst labelStr = label(data);\n\t\t\t\tconst titleStr = title(data);\n\t\t\t\treturn `<li>\n\t\t\t\t\t<button type=\"button\" aria-controls=\"${controls}\" aria-label=\"${titleStr}\" title=\"${titleStr}\">\n\t\t\t\t\t\t<span>${labelStr}</span>\n\t\t\t\t\t</button>\n\t\t\t\t</li>`;\n\t\t\t}).join('')}\n\t\t</ul>\n\t`,\n\t/* eslint-enable indent */\n\n\tclassName: 'pagination',\n\tlabel: ({ index }) => `${index + 1}`,\n\ttitle: ({ index }) => `Go to ${index + 1}. page`,\n};\n\n\n/**\n * The feature to enable pagination controls.\n */\nexport class Pagination implements IFeature {\n\n\t/**\n\t * Creates an instance of this feature.\n\t * @param options are the options to configure this instance\n\t */\n\tconstructor(options: Options = {}) {\n\t\twriteCache(this, CACHE_KEY_CONFIGURATION, { ...DEFAULTS, ...options });\n\t\tthis._onClick = this._onClick.bind(this);\n\t}\n\n\t/**\n\t * Returns the name of this feature.\n\t */\n\tpublic get name(): typeof FEATURE_NAME {\n\t\treturn FEATURE_NAME;\n\t}\n\n\t/**\n\t * Initializes this feature. This function will be called by the carousel\n\t * instance and should not be called manually.\n\t * @internal\n\t * @param proxy the proxy instance between carousel and feature\n\t */\n\tpublic init(proxy: IProxy): void {\n\t\twriteCache(this, CACHE_KEY_PROXY, proxy);\n\t\tthis._add();\n\t}\n\n\t/**\n\t * Destroys this feature. This function will be called by the carousel instance\n\t * and should not be called manually.\n\t * @internal\n\t */\n\tpublic destroy(): void {\n\t\tthis._remove();\n\t\tclearFullCache(this);\n\t}\n\n\t/**\n\t * This triggers the feature to update its inner state. This function will be\n\t * called by the carousel instance and should not be called manually. The\n\t * carousel passes a event object that includes the update reason. This can be\n\t * used to selectively/partially update sections of the feature.\n\t * @internal\n\t * @param event event that triggered the update\n\t * @param event.type is the update reason (why this was triggered)\n\t */\n\tpublic update(event: UpdateEvent): void {\n\t\tswitch (event.type) {\n\t\t\tcase UpdateType.SCROLL:\n\t\t\t\tthis._update();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthis._remove();\n\t\t\t\tthis._add();\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * Renders and adds the pagination element. Attaches event handlers to all\n\t * button elements.\n\t * @internal\n\t */\n\tprivate _add(): void {\n\t\tconst proxy = fromCache<IProxy>(this, CACHE_KEY_PROXY) as IProxy;\n\t\tconst config = fromCache<Configuration>(this, CACHE_KEY_CONFIGURATION) as Configuration;\n\t\tconst { el, mask, pages } = proxy;\n\t\tconst target = mask ?? el;\n\n\t\tif (pages.length < 2) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst { template, className, label, title } = config;\n\t\tconst pagination = render(template, { label, title, pages, className, controls: el.id });\n\n\t\tif (!pagination) {\n\t\t\treturn;\n\t\t}\n\n\t\t// @TODO: Add template for buttons:\n\t\tconst buttons = Array.from(pagination.querySelectorAll<HTMLButtonElement>('button'))\n\t\t\t.map((button) => {\n\t\t\t\t// The onClick listener is already bound in the constructor.\n\t\t\t\t//\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/unbound-method\n\t\t\t\tbutton.addEventListener('click', this._onClick, true);\n\t\t\t\treturn button;\n\t\t\t});\n\n\t\ttarget.parentNode?.appendChild(pagination);\n\t\twriteCache(this, CACHE_KEY_PAGINATION, pagination);\n\t\twriteCache(this, CACHE_KEY_BUTTONS, buttons);\n\n\t\tthis._update();\n\t}\n\n\t/**\n\t * Updates the states of all buttons inside the pagination.\n\t * @internal\n\t */\n\tprivate _update(): void {\n\t\tconst proxy = fromCache<IProxy>(this, CACHE_KEY_PROXY) as IProxy;\n\t\tconst buttons = fromCache<HTMLButtonElement[]>(this, CACHE_KEY_BUTTONS);\n\n\t\tconst { pageIndex } = proxy;\n\t\tbuttons?.forEach((button, at) => button.disabled = (at === pageIndex));\n\t}\n\n\t/**\n\t * Removes the whole pagination element and removes all attached event handlers.\n\t * @internal\n\t */\n\tprivate _remove(): void {\n\t\tconst pagination = fromCache<HTMLElement>(this, CACHE_KEY_PAGINATION);\n\t\tconst buttons = fromCache<HTMLButtonElement[]>(this, CACHE_KEY_BUTTONS);\n\n\t\tbuttons?.forEach((button) => {\n\t\t\t// The onClick listener is already bound in the constructor.\n\t\t\t//\n\t\t\t// eslint-disable-next-line @typescript-eslint/unbound-method\n\t\t\tbutton.removeEventListener('click', this._onClick);\n\t\t\tbutton.parentNode?.removeChild(button);\n\t\t});\n\t\tpagination?.parentNode?.removeChild(pagination);\n\n\t\tclearCache(this, CACHE_KEY_BUTTONS);\n\t\tclearCache(this, CACHE_KEY_PAGINATION);\n\t}\n\n\t/**\n\t * Event handler when a button is clicked. Detects the current index of the\n\t * clicked button inside the pagination and updates the index accordingly of\n\t * the carousel.\n\t * @internal\n\t * @param event the mouse event\n\t */\n\tprivate _onClick(event: MouseEvent): void {\n\t\tconst proxy = fromCache<IProxy>(this, CACHE_KEY_PROXY) as IProxy;\n\t\tconst buttons = fromCache<HTMLButtonElement[]>(this, CACHE_KEY_BUTTONS);\n\t\tif (!buttons) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst target = event.currentTarget as HTMLButtonElement;\n\t\tconst index = buttons.indexOf(target);\n\t\tproxy.index = proxy.pages[index];\n\t}\n\n}\n"],"names":["parcelHelpers","require","export","exports","_mask","Mask","Carousel","_proxy","_types","_cache","_debounce","ID_MATCH","EVENT_SCROLL","EVENT_RESIZE","CACHE_KEY_ELEMENT","CACHE_KEY_CONFIGURATION","CACHE_KEY_INDEX","CACHE_KEY_ITEMS","CACHE_KEY_PAGES","CACHE_KEY_PAGE_INDEX","CACHE_KEY_MASK","CACHE_KEY_FEATURES","VISIBILITY_OFFSET","INVISIBLE_ELEMENTS","__instanceCount","DEFAULTS","features","filterItem","onScroll","static","el","fromCache","this","mask","_a","id","index","items","length","clientWidth","outerLeft","getBoundingClientRect","left","at","rect","width","push","values","behavior","Array","isArray","value","Math","max","min","scrollLeft","from","to","offsetLeft","pages","clearCache","scrollTo","Object","assign","children","filter","item","test","tagName","hidden","viewport","map","sort","a","b","forEach","prevPage","firstItem","start","add","floor","page","pageIndex","visibles","reduce","acc","right","round","concat","rightA","findIndex","includes","destroy","removeAttribute","feature","removeEventListener","_onScroll","window","_onResize","clearFullCache","update","type","UpdateType","FORCED","event","SCROLL","target","originalEvent","RESIZE","constructor","options","ScrollBehavior","AUTO","Element","Error","writeCache","configuration","splice","proxy","Proxy","init","isNaN","SMOOTH","debounce","bind","addEventListener","_scrollbar","CACHE_KEY_PROXY","CACHE_KEY_HEIGHT","__scrollbar","enabled","className","name","Scrollbar","_render","_remove","element","height","dimensions","scrollWidth","document","createElement","style","overflow","parentNode","insertBefore","appendChild","marginBottom","_b","removeChild","interopDefault","__esModule","default","defineInteropFlag","defineProperty","exportAll","source","dest","keys","key","hasOwnProperty","enumerable","get","destName","cacheInstance","__CACHE","WeakMap","ref","factory","storage","Map","has","set","delete","CACHE_KEY_DIMENSIONS","inner","outer","body","position","top","visibility","h1","offsetHeight","h2","clientHeight","CACHE_KEY_INSTANCE","__getInstance","sender","FEATURE","instance","func","delay","timeout","args","clearTimeout","setTimeout","Buttons","CACHE_KEY_BUTTONS","EVENT_CLICK","template","controls","label","title","nextClassName","nextLabel","nextTitle","previousClassName","previousLabel","previousTitle","config","next","previous","join","handler","_onNext","_onPrev","params","__rest","button","render","nextSibling","isLastPage","undefined","disabled","isFirstPage","buttons","context","innerHTML","firstElementChild","Mouse","CACHE_KEY_POSITION_X","CACHE_KEY_SCROLL_LEFT","CACHE_KEY_TIMEOUT","CURSOR_GRAB","EVENT_DRAG","EVENT_END","__getPositionX","MouseEvent","clientX","indicator","cursor","_onStart","passive","userSelect","scrollBehavior","scrollSnapType","_onDrag","_onEnd","onStart","call","deltaX","_c","onDrag","threshold","distance","offset","abs","removeProperty","direction","requestAnimationFrame","_d","onEnd","Pagination","CACHE_KEY_PAGINATION","data","labelStr","titleStr","_add","_update","pagination","querySelectorAll","_onClick","currentTarget","indexOf"],"version":3,"file":"index.3c05876f.js.map"}